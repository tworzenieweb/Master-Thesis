\chapter{Optymalizacja kodu klienta}

Poniewa¿ g³ównym medium komunikacji w Internecie jest przegl¹darka, konieczna jest odpowiednia optymalizacja kodu klienta. Na pocz¹tku warto zacz¹æ od wyboru odpowiedniego noœnika informacji. Jak wiadomo, noœnikiem informacji w wypadku stron internetowych jest jêzyk znaczników \textit{HTML} (ang. \textit{HyperText Markup Language}). Obecnie najbardziej popularne s¹ trzy wersje standardu, okreœlane jako \textit{HTML 4}, \textit{XHTML 1.0} oraz nowy standard \textit{HTML 5}. Ka¿da wersja ma swoj¹ specyfikê, jednak nale¿y nadmieniæ, ¿e tylko HTML 5 pozbawiony jest starych nalecia³oœci tego jêzyka (znaczniki zwi¹zane z formatowaniem, a nie semantyk¹, ró¿na implementacja specyfikacji) i powoli staje siê standardem na rynku.\\

Wœród przeciwników wykorzystywania nowego standardu dominuj¹ opinie, ¿e nie jest on wspierany we wszystkich przegl¹darkach. Warto jednak okreœliæ kilka istotnych faktów, zwi¹zanych z obecnie wykorzystywanymi przegl¹darkami. Wed³ug statystyk na dzieñ 5 lutego 2012, udzia³ przegl¹darek Internet Explorer 6 i 7 w rynku wynosi odpowiednio \textbf{0,69\%} oraz \textbf{2,34\%}. O ile przegl¹darkê w wersji 7 i powy¿ej nale¿y mieæ jeszcze na uwadze, to IE6 mo¿na uznaæ ju¿ za przestarza³¹ i stopniowo ograniczaæ iloœæ czasu poœwiêcanego na implementacjê kompatybilnej wstecz witryny internetowej.\\

Dobrym zwyczajem jest jednak zapewnienie witrynie jak najlepszego dostosowania do obecnych na rynku przegl¹darek, dlatego rewolucyjnym pomys³em wykazali siê Nicolas Gallagher, Paul Irish oraz Divya Manian, czyli czo³owi projektanci, programiœci takich firm, jak Twitter, Opera, Chrome. Stworzyli oni bibliotekê \textit{HTML5 Boilerplate}. Stanowi ona fundament tworzenia dokumentów HTML/CSS/JS, wykorzystuj¹c najnowsz¹ wiedzê w dziedzinie optymalizacji \textit{front-endu} aplikacji. Wykorzystanie tej biblioteki zapewni znormalizowanie wygl¹du, zachowania oraz wydajnoœci ka¿dej aplikacji, chc¹cej u¿ywaæ technologiê \textit{HTML5} i nie tylko. Biblioteka \textit{HTML5 Boilerplate} zapewnia kompatybilnoœæ z innymi przegl¹darkami (nawet Internet Explorer 6). Do³¹czony do niej zbiór regu³ i dyrektyw dla serwerów WWW optymalizuje czas reakcji strony, dziêki kompresji i buforowaniu zasobów. Dodatkowo istnieje mo¿liwoœæ ukrywania komponentów strony, które nie s¹ wspierane przez starsze przegl¹darki, na przyk³ad wprowadzony do jêzyka \textit{HTML5} znacznik \texttt{<canvas>} lub nowe znaczniki do prezentacji plików multimedialnych. Stwarza to mo¿liwoœæ zast¹pienia niewspieranych elementów i zast¹pienia alternatywnymi rozwi¹zaniami. Biblioteka zawiera równie¿ wiele udogodnieñ zwi¹zanych z wyœwietlaniem stron na ekranie telefonów komórkowych i tabletów.

Stworzona w ramach niniejszej pracy aplikacja wykorzystuje udogodnienia oferowane przez \textit{HTML5 Boilerplate}. Dodatkowo, aplikacja wykorzystuje bibliotekê \textit{Twitter Bootstrap}, której celem jest zapewnienie funkcjonalnych komponentów, które mo¿na wykorzystaæ do ³atwej i spójnej prezentacji treœci. Jedn¹ z zalet wykorzystania tego rozwi¹zania, jest oparcie szablonu strony na \textit{siatce} (ang. \textit{grid}). W ten sposób wszystkie elementy s¹ wymiarowane w sposób jednakowy. Dodatkowo, udostêpniana jest mo¿liwoœæ tworzenia dynamicznych szablonów, które adaptuj¹ siê do rozdzielczoœci lub po prostu wielkoœci okna. Jest to cenne udogodnienie dla posiadaczy telefonów komórkowych, poniewa¿ nie trzeba poœwiêcaæ dodatkowego czasu na adaptacjê do wersji mobilnej.

\textit{Twitter Bootstrap} zawiera zbiór elementów graficznych i funkcjonalnych, takich jak przyciski, okienka informacyjne, dynamicznie animowane galerie, komponenty autouzupe³niania treœci pól, komponenty nawigacyjne i wiele innych typowych dla specyfiki aplikacji webowych elementów. Ca³oœæ jest spójna i pozwala na zapewnienie jednolitego interfejsu na ca³ej stronie. Dodatkowo, podobnie jak w wypadku \textit{HTML5 Boilerplate}, u¿ytkownik ma zapewnion¹ kompatybilnoœæ wstecz dla prawie wszystkich dostêpnych na rynku rozwi¹zañ.\\

Poniewa¿ biblioteka \textit{Twitter Bootstrap} realizuje za³o¿enia semantyczne jêzyka \textit{HTML5}, iloœæ kodu potrzebna do stworzenia strony jest naprawdê niewielka. W ten sposób dokumenty s¹ lekkie i szybciej siê wczytuj¹. Dodatkowo, dziêki mo¿liwoœciom CSS (kaskadowe arkusze styli) w wersji 3, mo¿liwe jest tworzenie atrakcyjnych wizualnie efektów bez koniecznoœci tworzenia przez projektantów dodatkowych grafik W ten sposób iloœæ ¿¹dañ jest redukowana do niezbêdnego minimum.

Rysunek \ref{fig:frontend} przedstawia wygl¹d interfejsu u¿ytkownika po zastosowaniu wspomnianych wczeœniej technologii. Jak widaæ strona dostosowuje siê do ró¿nych szerokoœci przegl¹darki, dziêki wykorzystaniu p³ynnych szablonów (ang. \textit{fluid templates}).

\begin{figure}[htbp]
\center
\caption{Ekran przedstawiaj¹cy interfejs u¿ytkownika stworzonej ksiêgarni internetowej} 
\includegraphics[scale=0.55]{frontend.pdf}
\label{fig:frontend}
\end{figure}

\section{Przetwarzanie danych pochodz¹cych z \textit{webserwisów}}

W celu rozszerzenia mo¿liwoœci jêzyka \textit{JavaScript} zastosowano framework \textit{jQuery}. Pomaga on w zapewnieniu kompatybilnoœci tworzonego kodu dla ró¿nych przegl¹darek. Oczywiœcie w³¹czaj¹c przegl¹darkê IE6. Framework \textit{jQuery} jest szczególnie przydatny ze wzglêdu na zaawansowane funkcjonalnoœci do obs³ugi zapytañ asynchronicznych AJAX. Jest to szczególnie wa¿ne, poniewa¿ razem z ¿¹daniem i jego specyfikacj¹ konieczne jest, by wys³aæ równie¿ zahaszowane dane autoryzacyjne. Ca³oœæ opiera siê na pierwszym zalogowaniu, podczas którego do sesji u¿ytkownika trafia kod autoryzacyjny u¿yty do pomyœlnego zalogowania \cite{book:jquery}. W ten sposób us³ugi wiedz¹, ¿e dostêp do nich zosta³ zweryfikowany. Jego brak poskutkowa³by b³êdem autoryzacji - kod 401. W przysz³oœci mo¿na t¹ funkcjonalnoœæ rozszerzyæ o autoryzacjê, wykorzystuj¹c standard \textit{OAuth 2.0}, zaimplementowany miêdzy innymi w Twitterze lub w \textit{Facebook Graph API}.\\

Listing \ref{listing:js} przedstawia implementacjê logiki realizuj¹cej wysy³anie komentarzy do webserwisu, odpowiedzialnego za dodawanie komentarzy. Do poprawnego dzia³ania konieczna jest znajomoœæ nag³ówka autoryzacyjnego, wiêc musi on byæ przekazany do obiektu \textit{XMLHTTPRequest} \cite{book:javascript} jeszcze przed wys³aniem zapytania. Dodatkow¹ funkcjonalnoœci¹ jest wyœwietlanie uaktualnionych komentarzy zaraz po zapisaniu danych. Odpowiedzialna jest za to funkcja \texttt{reloadComments()}, która dodatkowo wykorzystuje now¹ mo¿liwoœæ jêzyka \textit{JavaScript}, mo¿liw¹ dziêki odpowiednim wtyczkom. Polega ona na tworzeniu szablonów, które s¹ póŸniej ³¹czone z danymi, tak jak to odbywa siê na przyk³ad w innych technologiach po stronie serwera. Mowa tu o \textit{Jquery Templates}, które mog¹ w przysz³oœci trafiæ do standardu jêzyka \textit{JavaScript}.


\begin{lstlisting}[language=html, caption=Kod odpowiedzialny za realizacjê dodawania komentarzy, label=listing:js]
<script id="commentTemplate" type="text/x-jquery-tmpl"> 
    <div class="row-fluid">
          <h4>${title} {{html $item.getStars()}}</h4>
           <p>${content}</p>
          <p>${date}${user.first_name} ${user.last_name} (${user.username})</p>
    </div>
</script>

<script>
    var url = "<?php echo sfConfig::get('app_gae') . 'comments/' . $book['id'] . '/'; ?>";
    
    var reloadComments = function() {
        $("#comments").html('');
        $.getJSON(url, function(data) {
           
           /* Render the template with the data */
           $( "#commentTemplate" ).tmpl( data, { 
    getStars: function( ) {
        var str = '';
        for(i=0; i < this.data.grade; i++) {
            str += '<i class="icon-star"></i>'
        }
        
        for(j=i; j < 5; j++) {
            str += '<i class="icon-star-empty"></i>'
        }
        
        return str;
    }
}).appendTo( "#comments" );
           
       });
        
    }
    
    $(function() {
       
       reloadComments();
       
       
       $('#commentForm').submit(function (e){
           e.preventDefault();
           
           $.ajax({
               url: url,
               data: $(this).serialize(),
               xhrFields: {
                   withCredentials: true
                   
               },
               type: 'POST',
               
               beforeSend: function(xhr) {
                    xhr.setRequestHeader("Authorization", "<?php echo $sf_user->getAttribute('user_authorization', null, 'sfGuardSecurityUser') ?>");
               },
               
               success: function(data) {
                   reloadComments();
               }
           });
           
       });
       
    });
</script>
\end{lstlisting}

Jak wynika z listingu \ref{listing:js}, metoda \texttt{reloadComments()} odpowiedzialna jest za przetwarzanie danych komentarzy powi¹zanych z konkretn¹ ksi¹¿k¹ i wyœwietlenie odpowiedniej iloœci "gwiazdek" na podstawie oceny u¿ytkownika. Jest to przyk³ad odci¹¿enia \textit{back-endu} aplikacji, na rzecz przetwarzania po stronie klienta \cite{book:ajaxphp}.

Podobny sposób przetwarzania danych wykorzystany jest do pobierania listy kategorii dostêpnych dla ksi¹¿ek (Listing \ref{listing:js_cat}). Do prezentacji pojedynczego wpisu stworzono szablon. W ten sposób w miejsca oznaczone symbolami \texttt{\${title}} i podobnymi, wstawiane s¹ dane z obiektu \textit{JSON}.

\begin{lstlisting}[language=html, caption=Kod odpowiedzialny za wyœwietlanie kategorii, label=listing:js_cat]
<script id="categoryTemplate" type="text/x-jquery-tmpl"> 
    <li>
        <a href="${$item.url()}">${name}
            <span class="badge badge-success">${count}</span>
        </a>
    </li>
</script>


<script>
    var urlCat = "<?php echo sfConfig::get('app_gae'); ?>categories/";
    var link = "<?php echo url_for('@category_slug?slug=' . 'slug'); ?>";
    $(function() {
        
        $.getJSON(urlCat, function(data) {
            
           /* Render the template with the movies data */
           $( "#categoryTemplate" ).tmpl( data, {
               url: function() {
                   
                   return link.replace('slug', this.data.slug);
                   
               }
           }).appendTo( "#category" );
            
        });
        
    });
    
</script>
\end{lstlisting}

\section{Optymalizacja kodu \textit{HTML} oraz zasobów}

Optymalizacja kodu \textit{HTML} ma na celu zapewnienie szybkiego przetwarzania odpowiedzi serwera przez przegl¹darkê. Jedn¹ z wa¿niejszych optymalizacji jest usuniêcie definicji styli zawartych w znacznikach, na rzecz ujednoliconych definicji w arkuszu styli. Optymalizacja ta wprowadza uporz¹dkowanie do tworzonego kodu, zmniejsza rozmiar kodu HTML oraz przyspiesza renderowanie strony przez przegl¹darkê. £atwiej jest bowiem wczytaæ wszystkie regu³y dekoracji znaczników w jednym miejscu ni¿ sprawdzaæ ka¿dy znacznik z osobna \cite{book:yahoo}. 

Kolejna wa¿na optymalizacja polega na redukcji iloœci ¿¹dañ, jakie wykonuje przegl¹darka. Aby to osi¹gn¹æ nale¿y wykorzystaæ narzêdzia s³u¿¹ce do kompresji kodu wynikowego \textit{JavaScript} oraz \textit{CSS}. Jeœli z³¹czymy wszystkie arkusze styli w jeden plik, podobnie jak kod \textit{JavaScript}, iloœæ ¿¹dañ ulegnie zmniejszeniu, przyspieszaj¹c jednoczeœnie czas wczytywania strony. Zgodnie z \cite{book:yahoo}, dobrze jest wykorzystaæ osobne serwery do sk³adowania plików statycznych. Pojêcie to, znane jako CDN (ang. \textit{Content Delivery Network}) jest szczególnie rozpowszechnione w wypadku popularnych bibliotek JavaScript. Kod frameworka \textit{jQuery} umieszczony jest w³aœnie na jednym z takich serwerów (\textit{google apis}), podobnie jak biblioteka \textit{jQuery Validate}, dokonuj¹ca weryfikacji danych formularza.

Jednym z przydatnych dodatków do frameworka \textit{Symfony} jest wtyczka \textit{sfCombine}, oferuj¹ca du¿e mo¿liwoœci w zakresie optymalizacji zasobów. Za jej pomoc¹ mo¿liwe jest skompresowanie i z³¹czenie wszystkich zasobów \textit{JavaScript} w jeden plik, podobnie jak arkuszy \textit{CSS}. Dodatkowo, wtyczka kontroluje nag³ówki \textit{HTTP} wysy³ane do przegl¹darki. W ten sposób przegl¹darka pobiera now¹ wersjê zasobów, tylko w sytuacji, kiedy te uleg³y zmianie, w przeciwnym wypadku korzysta z lokalnej wersji. Myœlê, ¿e nie trzeba nadmieniaæ, jak du¿o mo¿na w ten sposób osi¹gn¹æ.

\begin{figure}[htbp]
\center
\caption{Analiza iloœci ¿¹dañ aplikacji ksiêgarni elektronicznej bez w³¹czonych optymalizacji} 
\includegraphics[scale=0.7]{minify_no.pdf}
\label{fig:minify_no}
\end{figure}

Na rysunku \ref{fig:minify_no} widaæ czas oczekiwania oraz iloœæ ¿¹dañ wysy³anych do serwera w celu pobrania strony. S¹ to statystyki bez w³¹czonej wtyczki kompresuj¹cej. Oczywiœcie w wypadku naszej aplikacji mamy tylko trzy arkusze styli i jeden plik \textit{Javascript} niepochodz¹cy z \textit{CDN} i przechowywany lokalnie. Korzyœci przy w³¹czeniu wtyczki nie powinny byæ wiêc tak znaczne, jak w przypadku aplikacji z³o¿onej z kilkunastu plików z zasobami. Dane zawarte na rysunku \ref{fig:minify_yes}, pokazuj¹ jednak, ¿e nawet w wypadku prostej aplikacji, warto kompresowaæ jej zawartoœæ. Redukcja ¿¹dañ z 11 do 9 nie jest mo¿e a¿ jest tak imponuj¹ca, jak fakt, ¿e ³¹czny czas oczekiwania uda³o siê zredukowaæ o 50\%, a transfer danych zmniejszy³ siê 50 razy. Jak widaæ, wszystkie zasoby zwracaj¹ status \textit{304}, okreœlaj¹cy, ¿e zasoby nie zosta³y zmodyfikowane, dziêki czemu serwer korzysta z lokalnej wersji.\\


\begin{figure}[htbp]
\center
\caption{Analiza ¿¹dañ aplikacji ksiêgarni elektronicznej z w³¹czon¹ optymalizacj¹} 
\includegraphics[scale=0.9]{minify_yes.pdf}
\label{fig:minify_yes}
\end{figure}

Optymalizacje po stronie klienta s¹ bardzo wa¿ne, poniewa¿ bezpoœrednio wp³ywaj¹ na czas po jakim klient zobaczy stronê. Ka¿dy kilobajt danych wiêcej do pobrania, odpowiednio wyd³u¿a czas wczytywania strony, dlatego zastosowano kompresjê zasobów oraz ich z³¹czenie. Dodatkowo, dziêki wykorzystaniu nag³ówków \textit{HTTP}, mo¿liwe jest ograniczenie danych, które pobiera przegl¹darka w chwili pobierania strony.