\chapter{Analiza jakoœciowa i wydajnoœciowa aplikacji}

Projektuj¹c aplikacje, ju¿ w fazie projektowej, nale¿y myœleæ o zapewnieniu wysokiej wydajnoœci, a tak¿e o potencjalnych problemach, które mog¹ siê pojawiæ po wdro¿eniu oprogramowania. W celu zapewnienia tworzonej aplikacji najwy¿szej skutecznoœci pracy, nale¿y wzi¹æ pod uwagê wiele cech, wœród których najwa¿niejsze zdefiniowane s¹ poni¿ej.

\begin{description}
\item[Skalowalnoœæ (ang. \textit{Scalability})] Cecha aplikacji, okreœlana jako zdolnoœæ do wzrostu wydajnoœci aplikacji wraz ze zwiêkszeniem iloœci dostêpnych zasobów sprzêtowych (serwery WWW, bazy danych, wydajniejsze procesory).

\item[Niezawodnoœæ (ang. \textit{High availability})] Stanowi projekt, jak i odpowiedni¹ implementacje systemu, zapewniaj¹ca okreœlony poziom ci¹g³oœci wykonywania operacji w czasie. Polega to na zapewnieniu jak najwiêkszej dostêpnoœci us³ugi.

\item[Wydajnoœæ (ang. \textit{Performance})] Przek³ada siê na mo¿liwoœæ szybkiego wykonywania kodu aplikacji oraz utrzymania czasu odpowiedzi aplikacji na stosownym poziomie.
\end{description}

Czêsto skalowalnoœæ jest mylona z wydajnoœci¹, jednak przek³adaj¹c to na bardziej ¿yciowy przyk³ad, wydajnoœæ aplikacji mo¿na porównaæ do szybkiego samochodu. Z drugiej strony, bez zapewnienia odpowiednich dróg, ten szybki samochód lub ich grupa, nie jest w stanie rozwin¹æ maksymalnej prêdkoœci. W najgorszym wypadku mo¿e nawet utkwiæ w korku, blokowany przez inne pojazdy. 
Skalowalnoœæ jest wiêc zapewnieniem \textbf{odpowiedniej infrastruktury}, gwarantuj¹cej w³aœciwy rozrost systemu.\\

W celu zapewnienia mo¿liwie najlepszej jakoœci tworzonej aplikacji, nale¿y stale monitorowaæ aktualny poziom wydajnoœci aplikacji. Nale¿y jednak mieæ na uwadze, ¿e na wydajnoœæ aplikacji sk³ada siê czas przetwarzania poszczególnych wêz³ów systemu. Nale¿y wiêc testowaæ ka¿de z nich osobnymi metodami, omówionymi w dalszej czêœci pracy.

Szukaj¹c przyczyn b³êdów, warto rozpocz¹æ analizê od najbardziej ogólnego komponentu, czyli od serwera WWW, odpowiedzialnego za wysy³anie odpowiedzi na ¿¹danie u¿ytkownika. Nastêpnie nale¿y dokonaæ dekompozycji, wyró¿niaj¹c kolejne wêz³y systemu, takie jak dalsze instancje serwera WWW lub serwery bazodanowe.

\section{Analiza wydajnoœci serwera WWW}

Zadaniem serwera WWW jest wys³anie do inicjatora ¿¹dania wyniku przetwarzania zasobu okreœlonego adresem URL. W najprostszym wypadku, analiza wydajnoœci serwera, polega na odpytaniu go o okreœlony zasób i zmierzenie czasu od rozpoczêcia tej akcji, do odebrania rezultatu. Taki proces mo¿na przeœledziæ i przeanalizowaæ w wiêkszoœci popularnych przegl¹darek, na przyk³ad Google Chrome, które jest wyposa¿one w wiele przydatnych narzêdzi analitycznych (Rys. \ref{fig:rys1_chrome}).

\begin{figure}[htbp]
\caption{Analiza czasu wykonywania strony \textit{http://ftims.edu.p.lodz.pl//} wykonana w przegl¹darce Google Chrome}
\label{fig:rys1_chrome}
\includegraphics[scale=0.71]{rys1_chrome.pdf}
\end{figure}

Taki sposób analizy jest jednak przydatny jedynie w wypadku znacznych problemów z wydajnoœci¹ aplikacji, poniewa¿ testowanie czasu odpowiedzi dla pojedynczego u¿ytkownika, wykonuj¹cego pojedyncze ¿¹danie, nie jest w ¿adnym stopniu miarodajne.\\

W celu zapewnienia bardziej rzetelnego testu, nale¿y skorzystaæ z dedykowanych rozwi¹zañ, takich jak \texttt{ab} oraz \texttt{siege}. 
S¹ to typowe narzêdzia przeznaczone do sprawdzania, jak dobrze serwer radzi sobie z obs³ug¹ bardziej z³o¿onego ruchu sieciowego. 
Przyk³adowo, dla wczeœniej u¿ytej strony, mo¿na zasymulowaæ ruch równy wykonaniu 10 jednoczesnych ¿¹dañ przez 10 niezale¿nych u¿ytkowników. 
W tym celu nale¿y wydaæ komendê \lstinline{ab -n 10 -c 10 http://ftims.edu.p.lodz.pl/}. Rezultat dzia³ania komendy widoczny jest na listingu \ref{listing:ab}.

\begin{lstlisting}[float=htpbm, caption=Analiza strony z wykorzystaniem narzêdzia \texttt{ab}, label=listing:ab]
Server Software:        Apache/2.2.14
Server Hostname:        ftims.edu.p.lodz.pl
Server Port:            80

Document Path:          /
Document Length:        48759 bytes

Concurrency Level:      10
Time taken for tests:   0.695 seconds
Complete requests:      10
Failed requests:        0
Write errors:           0
Total transferred:      492510 bytes
HTML transferred:       487590 bytes
Requests per second:    14.38 [#/sec] (mean)
Time per request:       695.270 [ms] (mean)
Time per request:       69.527 [ms] (mean, across all concurrent requests)
Transfer rate:          691.77 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       52   63   7.4     63      74
Processing:   300  503  90.9    532     632
Waiting:      127  233  62.8    235     381
Total:        354  565  92.9    593     695

Percentage of the requests served within a certain time (ms)
  50%    593
  66%    612
  75%    625
  80%    628
  90%    695
  95%    695
  98%    695
  99%    695
 100%    695 (longest request)

\end{lstlisting}

Jak mo¿na wywnioskowaæ z powy¿szych danych, narzêdzie wykonuje wiele przydatnych analiz, a tak¿e wyœwietla informacje o badanym zasobie. 
Widaæ przede wszystkim, ¿e czas oczekiwania na stronê przy 10 u¿ytkownikach jest prawie trzykrotnie d³u¿szy, ni¿ podczas jednego ¿¹dania wykonanego w przegl¹darce. 

Oczywiœcie na wyniki pomiarów ma tak¿e wp³yw prêdkoœæ po³¹czenia internetowego, dlatego w celu pominiêcia dodatkowych czynników, testy docelowej aplikacji bêd¹ wykonywane przede wszystkim na lokalnym serwerze. 
Najbardziej miarodajn¹ jednostk¹, okreœlaj¹c¹ wydajnoœæ aplikacji w wypadku narzêdzia \textit{ab} jest liczba zapytañ na sekundê (\textit{req/s}). 
Okreœla ona maksymaln¹ iloœæ ¿¹dañ w jednostce czasu, jak¹ aplikacja jest w stanie obs³u¿yæ. Oczywiœcie im wiêksza wartoœæ, tym lepsza ogólna wydolnoœæ aplikacji.\\

Na rysunku \ref{fig:rys2_http_lifecycle} przedstawiono cykl ¿ycia ¿¹dania od u¿ytkownika inicjuj¹cego je, koñcz¹c na odebraniu odpowiedzi serwera. Jak mo¿na zauwa¿yæ ¿¹danie przebywa stosunkowo d³ug¹ drogê, nim trafi do faktycznej aplikacji. Wynikiem tego s¹ dodatkowe opóŸnienia, zale¿ne od stopnia skomplikowania architektury trzech pierwszych wêz³ów. 
Dlatego te¿ nale¿y mieæ na uwadze, ¿e problemy z szybkoœci¹ dzia³ania aplikacji nie musz¹ le¿eæ wy³¹cznie po stronie aplikacji lub serwera. 
Do najbardziej popularnych nale¿¹: niska przepustowoœæ ³¹cza internetowego klienta, wolny serwer DNS, daleka lokalizacja geograficzna serwera WWW, Ÿle skonfigurowany router lub bardzo obci¹¿ona sieæ lokalna.

\begin{figure}[htbp]
\includegraphics[scale=0.55]{fig_request.pdf}
\caption{Cykl ¿ycia ¿¹dania w typowej aplikacji webowej}
\label{fig:rys2_http_lifecycle}
\end{figure}

Nawi¹zuj¹c do listingu \ref{listing:ab}, wartoœciami zwi¹zanymi ze wspomnianymi w poprzednim akapicie wêz³ami s¹ \texttt{Connect} oraz \texttt{Waiting}, czyli odpowiednio czas oczekiwania na po³¹czenie z zasobem i czas pobierania odpowiedzi z zasobu. Istnieje piêæ g³ównych czynników, wp³ywaj¹cych na czas odpowiedzi serwera.

\begin{description}

\item[Po³o¿enie geograficzne i problemy z sieci¹ komputerow¹]

Nie bez znaczenia dla czasu odpowiedzi, jaki u¿ytkownik odczuwa jest te¿ lokalizacja serwerów stron. Jeœli serwery s¹ zlokalizowane w USA, a u¿ytkownicy odwiedzaj¹cy stronê s¹ na przyk³ad z Europy, dystans, jaki musi pokonaæ ¿¹danie od momentu dotarcia do zasobu, oczekiwania, a¿ do jego pobrania jest nie wspó³miernie wiêkszy ni¿ w wypadku stron hostowanych dla tego samego po³o¿enia geograficznego. 
Stopieñ opóŸnienia jest zazwyczaj uzale¿niony od iloœci routerów, serwerów poœrednich, a nawet oceanów, które pokonuje ¿¹danie od punktu pocz¹tkowego do odbiorcy i z powrotem.

\item[Wielkoœæ dokumentu odpowiedzi serwera] Zale¿noœæ miêdzy wielkoœci¹ dokumentu, a czasem odpowiedzi serwera jest oczywista, ³atwo wiêc sprawdziæ, ¿e im wiêkszy dokument trzeba pobraæ, tym wiêcej czasu potrzeba na zakoñczenie tego procesu. Implikuje to koniecznoœæ optymalizacji wielkoœci strony.

\item[Wykonywanie kodu aplikacji] Najczêstsza przyczyna wolnego dzia³ania aplikacji to w³aœnie brak optymalizacji kodu klienta. D³ugi czas wykonywania kodu aplikacji implikuje d³ugi czas ³¹czny oczekiwania na odpowiedŸ serwera. Problem ten zostanie szczegó³owiej poruszony w rozdziale \ref{cha:optymalizacja_aplikacji}.

\item[Rodzaj u¿ytej przegl¹darki] Nie bez znaczenia dla ogólnego czasu ³adowania strony jest równie¿ rodzaj u¿ytej przegl¹darki. Czêsto wbudowane w przegl¹darkê wewnêtrzne mechanizmy buforowania zasobów pozwalaj¹ w znaczny sposób zredukowaæ iloœæ zapytañ wysy³anych do serwera. Dotyczy to zw³aszcza danych statycznych ,takich jak arkusze CSS, pliki JavaScript lub zasoby graficzne, które nie zmieniaj¹ siê zbyt czêsto. 

\item[Konfiguracja serwera WWW] W zale¿noœci od u¿ytej technologii, istnieje wiele ró¿nych serwerów HTTP. Wœród najczêœciej u¿ywanych, prym wiedzie serwer HTTP \textit{Apache}. 
Dla rozwi¹zañ napisanych w technologii Java czêsto wykorzystywane s¹ serwery \textit{GlassFish}, \textit{Tomcat}, \textit{Jetty}. W wiêkszoœci wypadków zaraz po instalacji, oprogramowanie serwera nie nadaje siê jeszcze do wykorzystania w produkcji. 
Nale¿y wywa¿yæ ustawienia serwera do bie¿¹cych potrzeb, poniewa¿ w wiêkszoœci wypadków domyœlne ustawienia mog¹ znacznie obni¿yæ ogóln¹ wydajnoœæ. 
Innym wa¿nym dzia³aniem jest dostosowywanie serwera do konkretnych zastosowañ - do serwowania plików statycznych lepszym rozwi¹zaniem jest wykorzystanie bardziej oszczêdnego pamiêciowo i operacyjnie serwera \textit{Ngnix}, natomiast do bardziej zaawansowanych zastosowañ, w tym wykonywanie kodu aplikacji, serwera Apache lub osobnej instancji serwera \textit{Ngnix}.

\end{description}

Administratorzy serwerów WWW maj¹ bezpoœredni dostêp do statystyk odwiedzalnoœci stron, przez co pozwala to zaobserwowaæ pewne trendy odwiedzin u¿ytkowników. 
Czêsto jest tak, ¿e dane zasoby s¹ du¿o intensywniej odpytywane przez u¿ytkowników na przyk³ad w czasie 10 minut stronê odwiedza 100 u¿ytkowników. 
£atwo to sobie wyobraziæ na przyk³ad w wypadku premiery jakiejœ nowej gry lub publikacji wyników egzaminu na uczelni. 
Taki periodyczny, lecz bardzo wzmo¿ony ruch mo¿e powodowaæ pewne trudne do ustalenia problemy z dzia³aniem aplikacji. Dlatego te¿ twórcy narzêdzia \texttt{ab}, zaimplementowali równie¿ mo¿liwoœæ testów czasowych (ang. \textit{timed tests}). W ten sposób mo¿na zasymulowaæ, jak strona bêdzie siê zachowywa³a równie¿ w takich nag³ych wypadkach.\\

Wydaj¹c komendê \lstinline{ab -c 10 -t 30 http://ftims.edu.p.lodz.pl/} mo¿na sprawdziæ, jak zachowa siê aplikacja odwiedzana przez 10 u¿ytkowników jednoczeœnie w czasie 30 sekund. Ta komenda pozbawiona jest parametru \textit{-t iloœæ ¿¹dañ}, co oznacza, ¿e symulacja zakoñczy siê po 30 sekundach lub po osi¹gniêciu limitu 50 000 ¿¹dañ.

\begin{lstlisting}[caption=Test obci¹¿enia czasowego, label=listing:ab_2]
Benchmarking ftims.edu.p.lodz.pl (be patient)
Finished 504 requests

Server Software:        Apache/2.2.14
Server Hostname:        ftims.edu.p.lodz.pl
Server Port:            80

Document Path:          /
Document Length:        48759 bytes

Concurrency Level:      10
Time taken for tests:   40.180 seconds
Complete requests:      504
Failed requests:        0
Write errors:           0
Total transferred:      24822504 bytes
HTML transferred:       24574536 bytes
Requests per second:    12.54 [#/sec] (mean)
Time per request:       797.213 [ms] (mean)
Time per request:       79.721 [ms] (mean, across all requests)
Transfer rate:          603.31 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       48   65  14.3     61     145
Processing:   284  436 288.9    376    2957
Waiting:      119  199 281.5    151    2660
Total:        333  500 287.8    439    3007

Percentage of the requests served within a certain time (ms)
  50%    439
  66%    458
  75%    477
  80%    493
  90%    563
  95%    666
  98%   1420
  99%   2142
 100%   3007 (longest request)

\end{lstlisting}

Listing \ref{listing:ab_2} przedstawia wynik testów czasowych. Najwa¿niejsz¹ informacj¹ z punktu widzenia optymalizacji jest iloœæ ¿¹dañ na sekundê, która w tym wypadku wynosi \texttt{12.54}. Narzêdzie \texttt{ab} pozwala równie¿ zdiagnozowaæ potencjalne b³êdy aplikacji pod wp³ywem zbyt du¿ego ruchu. 
Pola takie, jak \texttt{Failed requests} oraz \texttt{Write errors} u³atwiaj¹ okreœlenie prawid³owoœci wykonywania ¿¹dañ. W powy¿szym przyk³adzie wartoœci s¹ akceptowalne (œredni czas ¿¹dania to 0.5 sekundy), co najwa¿niejsze nie wystêpuj¹ b³êdy na poziomie serwera WWW i z du¿ym prawdopodobieñstwem równie¿ na poziomie aplikacji. Oczywiœcie zauwa¿alny jest spadek wydajnoœci w porównaniu z pierwszym testem. Co prawda wartoœci œrednie s¹ zbli¿one, jednak widaæ wiêksze rozbie¿noœci miêdzy wartoœciami minimalnymi a maksymalnymi. Najd³u¿sze zapytanie zajê³o ponad 3 sekundy. 

W dokumentacji aplikacji \texttt{ab}, mo¿na znaleŸæ informacjê, ¿e niektóre serwery mog¹ blokowaæ wysy³ane przez ni¹ nag³ówki HTTP. 
W tym celu mo¿na wykorzystaæ prze³¹cznik, umo¿liwiaj¹cy podanie siê za inn¹ przegl¹darkê. 
Na przyk³ad chc¹c zasymulowaæ odwiedziny przy u¿yciu przegl¹darki Chrome, nale¿y wykonaæ poni¿sz¹ komendê:\\
\lstinline{ab -n 100 -c 5 -H "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.447.0 Safari/534.2" http://www.example.com}.\\

Pomimo wielu zalet wynikaj¹cych z korzystania z narzêdzia \texttt{ab}, istnieje jedna zasadnicza wada. Aplikacja nie daje mo¿liwoœci przetestowania pewnego scenariusza lub jest to bardzo niewygodne, a przypadku aplikacji z wykorzystaniem technologii \textit{JavaScript} i \textit{AJAX} wrêcz niewykonalne.

Dlatego te¿ na prze³omie lat wyspecjalizowa³y siê bardziej zaawansowane narzêdzia przeznaczone do przeœledzenia logicznej kolejnoœci dzia³añ wykonywanych na stronie (pewnego przypadku u¿ycia) i wykonywanie analiz w³aœnie w ramach logicznego zbioru akcji. W ten sposób mo¿liwe jest przeprowadzenie tzw. \textit{testów funkcjonalnych}, a tak¿e sprawdzenie, w jakim stopniu s¹ one wra¿liwe na zwiêkszony ruch sieciowy. 

Jednym z przyk³adów takiego narzêdzia o naprawdê olbrzymich mo¿liwoœciach jest \textit{Apache JMeter}. Z jego pomoc¹ mo¿liwe jest nagranie pewnego ci¹gu akcji wykonanych przy pomocy przegl¹darki, a nastêpnie przeprowadzenie ci¹gu analiz i testów na tak wyodrêbnionym zbiorze. Tabela \ref{table:1_jmeter} pokazuje wynik dzia³ania przyk³adowego scenariusza, polegaj¹cego na symulowaniu wejœcia na stronê \texttt{http://www.wp.pl}, a nastêpnie klikniêciu jednego z linków wiadomoœci, po czym klikniêciu na kolejny link z dostêpnych na bie¿¹cej stronie. Ostatnim elementem ³añcucha akcji jest wys³anie komentarza do artyku³u. \textit{JMeter} podobnie, jak \texttt{ab} umo¿liwia wykonywanie równoleg³ych po³¹czeñ u¿ytkowników okreœlanych, jako w¹tki (\textit{threads}).\\

W zdefiniowanym przypadku u¿ycia piêciu u¿ytkowników wykonuje jednoczeœnie t¹ logikê 500 razy. Na zakoñczenie dane mo¿liwe s¹ do wyeksportowania do formatu \textit{CSV} lub wyœwietlone bezpoœrednio na ekranie. \textit{JMeter} jest narzêdziem bardzo rozbudowanym, przez co idealnie nadaje siê do testowania zaawansowanych scenariuszy zarówno pod k¹tem poprawnoœci dzia³ania, jak równie¿ ogólnej wydajnoœci.

\begin{table}
\centering
\caption{Tabela z rezultatem dzia³ania aplikacji \textit{JMeter}}
\begin{tabular}{@{}rrrrcrrrcrrr@{}}\toprule
URL & Œrednia & Min & Max & B³¹d (\%) & Req/Min \\
\bottomrule
..14543704,wiadomosc.html & 2299 & 415 & 94329 & 2.2 & 43.7 \\  
...1028235,wiadomosci.html & 2485 & 335 & 94434 & 2.8 & 43.7 \\  
...14545325,wiadomosc.html & 2023 & 394 & 94285 & 1.8 & 43.7 \\  
\bottomrule
\textbf{£¹cznie} & \textbf{2269} & \textbf{335} & \textbf{94434} & \textbf{2.27} & \textbf{131.1} \\  
\end{tabular}
\label{table:1_jmeter}
\end{table}

\section{Analiza wydajnoœci \textit{front-endu}}

W poprzednim podrozdziale zosta³a omówiona tematyka testowania czasu dzia³ania zasobów serwowanych przez serwer WWW. Wykorzystuj¹c wspomniane wczeœniej narzêdzia mo¿na jednoznacznie ustaliæ, czy aplikacja funkcjonuje w sposób prawid³owy, czy nie wystêpuj¹ b³êdy w pracy serwera oraz jak dobrze oprogramowanie radzi sobie ze wzmo¿onym obci¹¿eniem.

Wydawaæ by siê mog³o, ¿e problem testowania wydajnoœci aplikacji zosta³ jednoznacznie omówiony.
Nic bardziej mylnego. Jedynie w idealnym œwiecie strona WWW sk³ada³aby siê wy³¹cznie z tekstu, a u¿ytkownicy do przegl¹dania Internetu, korzystaliby wy³¹cznie z terminali.\\


Wspó³czesny u¿ytkownik Internetu do przegl¹dania jego zasobów wykorzystuje przegl¹darkê internetow¹, zdoln¹ do wyœwietlania zarówno tekstu, jak i mediów wszelakiego typu. Dlatego  te¿, dla wiêkszej precyzji, konieczne jest wyszczególnienie kluczowego komponentu oprogramowania, jakim jest \textit{front-end} aplikacji. 

W przypadku aplikacji internetowych, \textit{front-end} to interfejs graficzny s³u¿¹cy do komunikacji u¿ytkownika ze stron¹ i prezentacji danych opracowanych przez zaplecze systemu (\textit{back-end}) w sposób przystêpny i zrozumia³y.\\
 
Odpowiednia optymalizacja \textit{front-endu} jest o tyle wa¿na, ¿e jest to pierwsza technologia, z jak¹ u¿ytkownik ma kontakt w momencie korzystania z  aplikacji \textit{webowej} \cite{book:proPHP}.

\textit{Front-end} realizuje  przetwarzanie i analizê wyniku odpowiedzi serwera, przy czym obowi¹zuj¹cym jêzykiem komunikacji jest jêzyk HTML (\textit{HiperText Markup Language}). Od kilku lat w wyniku rozwoju trendu WEB 2.0, istotnym zabiegiem projektowanych aplikacji, staje siê przeniesienie czêœci logiki na stronê przegl¹darki (\textit{front-endu}). \textit{Cienkie} do tej pory aplikacje webowe (\textit{thin client}), zaczynaj¹  - dziêki zdobyczom technologicznym, takim jak \textit{AJAX}, realizuj¹c znacznie szerszy zakres funkcjonalny ni¿ dotychczas. Oznacza to, ¿e przetwarzanie danych mo¿e mieæ miejsce przy wykorzystaniu przegl¹darki internetowej i jêzyka \textit{JavaScript}. Dlatego te¿, kolejnym istotnym elementem analizy wydajnoœciowej staje siê analiza \textit{front-endu}.\\


Na podstawie badañ firmy \textit{Juniper}, stwierdzono, ¿e œredni czas, jaki u¿ytkownik jest w stanie poczekaæ na "za³adowanie" strony to zaledwie 4 sekundy. Nie warto wiêc traciæ potencjalnych klientów strony, tylko i wy³¹cznie z powodu braku optymalizacji po stronie przegl¹darki.

Wœród istniej¹cych na rynku rozwi¹zañ, s³u¿¹cych do analizy po stronie klienta, najpopularniejszymi s¹ te, które s¹ wbudowane bezpoœrednio w interfejs przegl¹darki internetowej (jest to przecie¿ najbardziej intuicyjne podejœcie). Jednym z pierwszych rozwi¹zañ tego typu by³a wtyczka \texttt{Firebug}, napisana dla przegl¹darki Firefox. Jest to obecnie najbardziej zaawansowane narzêdzie tego typu, rywalizuj¹ce jednoczeœnie z natywnymi dodatkami deweloperskimi dla przegl¹darki Chrome.\\

Interfejs Firebuga pozwala na szczegó³ow¹ inspekcjê kodu HTML wraz z mo¿liwoœci¹ dynamicznej operacji na wêz³ach DOM dokumentu HTML. Nie mniej wa¿nymi funkcjami s¹: mo¿liwoœæ wykonywania i debugowania kodu JavaScript na stronie, inspekcja zwi¹zanego z dokumentem HTML obiektu DOM, edycja i rewizja kodu JavaScript oraz narzêdzie do monitorowania ruchu sieciowego wykonywanego przez aplikacjê.

Ten ostatni modu³ pe³ni podobn¹ rolê, jak narzêdzie \texttt{ab}, jednak wyœwietla wszystkie zasoby, które maj¹ bezpoœrednie powi¹zanie z bie¿¹cym dokumentem HTML. Omawiane wczeœniej narzêdzia pokazywa³y jedynie czas renderowania dokumentu HTML, jednak nale¿y mieæ na uwadze, ¿e strona internetowa sk³ada siê z wielu ró¿nych zasobów, wœród których nie sposób pomin¹æ grafik, arkuszy CSS, kodu JavaScript, apletów Java lub obiektów Adobe Flash.

Ka¿da strona mo¿e zawieraæ zró¿nicowan¹ iloœæ takich zasobów, dlatego na ³¹czny czas ³adowania strony sk³ada siê zarówno czas oczekiwania na dokument HTML, jak równie¿ czas konieczny na pobranie ka¿dego z powi¹zanych z nim zasobów. 

Nawi¹zuj¹c do \cite{book:yahoo} istnieje zasada, która mówi, ¿e tylko 10-20\% czasu odpowiedzi jest spêdzane na oczekiwanie dokumentu HTML, natomiast pozosta³e 80-90\% to czas na pobieranie pozosta³ych zasobów i "³adowanie" zawartoœci DOM.

Przyk³ad analizy ruchu sieciowego na rysunku \ref{fig:ruch_sieciowy} jest najlepszym przyk³adem tej zasady. Strona wykonuje 32 zapytania do serwera, z czego tylko jedno to ¿¹danie dokumentu HTML. Pobranie tego dokumentu zajê³o oko³o 400ms, tymczasem ³¹czny czas wczytywania strony wyniós³ \textbf{3.21 sekundy}. Oznacza to, ¿e generowanie dokumentu zajê³o zaledwie \textbf{12\%} ³¹cznego czasu oczekiwania. 

Na podstawie danych z Firebuga ³atwo stwierdziæ pewne nieprawid³owoœci, bowiem w ramach strony wczytywane s¹ dwa stosunkowo du¿e (1,1 MB) dokumenty graficzne, które prawdopodobnie nie zosta³y wymiarowane do odpowiednich rozmiarów. \texttt{Firebug} stanowi wiêc cenne narzêdzie przy diagnostyce \textit{front-endu} strony. Narzêdzie staje siê jeszcze przydatniejszy przy pojawianiu siê elementów dynamicznych JavaScript, poniewa¿ pozwala œledziæ zarówno aktualnie wykonywany kod, jak równie¿ nas³uchiwaæ zapytañ asynchronicznych wykonywanych przez AJAX. Narzêdzie to mo¿e byæ równie¿ przydatne podczas œledzenia zmian dokonywanych w dokumencie HTML, za pomoc¹ narzêdzia inspekcji, umo¿liwia bowiem zbadanie ka¿dego wêz³a.

\begin{figure}[hbtp]
\includegraphics[scale=0.45]{rys3_firebug.pdf}
\caption{Analiza ruchu sieciowego na stronie \textit{http://ftims.p.lodz.pl}}
\label{fig:ruch_sieciowy}
\end{figure}

\section{Analiza wydajnoœci bazy danych}

Bardzo czêsto ogólna wydajnoœæ aplikacji uzale¿niona jest od szybkoœci operacji odczytu / zapisu bazy danych. W pewnym momencie twórcy aplikacji zaczynaj¹ oczekiwaæ od niej wiêkszej wydajnoœci. Nale¿y jednak zadaæ pytanie, co nale¿y tak naprawdê optymalizowaæ? Konkretne zapytanie? Schemat bazy? Czy mo¿e sprzêt, na którym baza danych pracuje? Jedynym sposobem na znalezienie jednoznacznej odpowiedzi, jest zmierzenie pracy wykonywanej przez bazê  i sprawdzenie wydajnoœci pod wp³ywem ró¿nych czynników \cite{book:mysql}.

Bazy danych ewoluowa³y na przestrzeni kilkunastu lat, pocz¹tkowo by³y to po prostu pliki o okreœlonej strukturze, jednak wraz ze wzrostem wymagañ zaczêto stosowaæ równoleg³y dostêp do danych, a tak¿e dbaj¹c o spójnoœæ danych, zaimplementowano system transakcji \cite{book:sql}.

Obecnie obserwuje siê specjalizacjê baz danych do konkretnych zastosowañ. Pomimo dominacji na rynku baz relacyjnych, opartych o standard \textit{SQL/93}, zaczêto równie¿ torowaæ drogê nowym rozwi¹zaniom, takim jak \textit{NoSQL}, czyli bazy danych o dynamicznej strukturze, pozbawionych œciœle zdefiniowanych schematów, przez co zyskuj¹ wiêksz¹ elastycznoœæ. Dodatkowo, w okreœlonych zastosowaniach tego typu bazy danych okazuj¹ siê du¿o szybsze ni¿ bazy relacyjne. Szybkoœæ ta jest tym wiêksza, im wiêksza jest przechowywana kolekcja danych. S¹ to wiêc bazy wysoce skalowalne, choæ mniej spójne ni¿ standardowe.\\

Wœród systemów bazodanowych, wykorzystywanych w aplikacji \textit{e-commerce}, bardzo du¿¹ popularnoœci¹ cieszy siê oprogramowania MySQL. Pomimo du¿o mniejszych mo¿liwoœci ni¿ na przyk³ad komercyjne rozwi¹zania Oracle lub MS SQL Server, omawiana baza danych jest elastyczna i ³atwo zaadaptowaæ j¹ do w³asnych potrzeb. Od czasu wprowadzenia zgodnoœci ze standardem ACID, MySQL zacz¹³ byæ szeroko wykorzystywany w \textit{e-biznesie}. 

\begin{figure}[hbtp]
\center
\caption{Schemat architektury MySQL}
\includegraphics[scale=0.5]{baza.pdf}
\label{fig:mysql_schemat}
\end{figure}

Rysunek \ref{fig:mysql_schemat} przedstawia, jak wygl¹da architektura systemu baz danych MySQL, z punktu widzenia funkcjonalnych komponentów \cite{book:proPHP}. Pierwsza warstwa zawiera us³ugi, które wbrew pozorom nie s¹ unikalne tylko dla omawianego oprogramowania. S¹ to us³ugi  charakterystyczne dla wiêkszoœci narzêdzi w architekturze sieciowej. Wyró¿niono wiêc obs³ugê po³¹czenia, uwierzytelnianie.
Druga warstwa wprowadza wiele zmian i komponentów specyficznych dla MySQL. 
Wyró¿niamy wiêc komponenty odpowiedzialne za parsowanie zapytañ, a tak¿e za ich optymalizacjê, buforowanie oraz kod odpowiedzialny za implementacjê wbudowanych funkcji (data, czas, funkcje matematyczne i kryptograficzne). Ka¿da funkcjonalnoœæ oferowana przez którykolwiek z silników sk³adowania danych (\textit{storage engine}), ma tu swoje miejsce (procedury u¿ytkownika, wyzwalacze oraz widoki) \cite{book:mysql}.

Trzecia warstwa wyró¿nia wszystkie silniki sk³adowania, które odpowiedzialne s¹ bezpoœrednio za przechowywanie i pobieranie danych w MySQL. Ka¿dy z silników ma ró¿ne zastosowania (podobnie, jak ró¿ne systemy plików w systemach operacyjnych). Komunikacja z ka¿dym z nich odbywa siê wykorzystuj¹c wewnêtrzne API. Wspomniany interfejs ukrywa ró¿nice w specyfice ka¿dego z mechanizmów, przez co zapytania s¹ bardziej abstrakcyjne i prostsze w u¿yciu dla u¿ytkownika koñcowego. Podobnie, jak w wypadku serwerów WWW, miêdzy mechanizmem sk³adowania a serwerem MySQL wystêpuje zale¿noœæ: \textit{¿¹danie - odpowiedŸ}. Oznacza to, ¿e serwer wysy³a ¿¹danie i oczekuje na odpowiedŸ.

Najlepsz¹ strategi¹ optymalizacji, jest szukanie miejsc aplikacji, które dzia³aj¹ najwolniej. Utworzono przyk³adowy schemat bazy danych (Rys. \ref{fig:baza_danych_test}). Na diagramie widaæ zale¿noœæ \textit{studenta}, który przynale¿y do jednego \textit{profilu} (nauczyciela), który z kolei nale¿y do organizacji. Podobnie \textit{student} mo¿e nale¿eæ do jednego z istniej¹cych \textit{kampusów}.

\begin{figure}[hbtp]
\center
\caption{Schemat testowej bazy danych}
\includegraphics[scale=1]{baza_test.pdf}
\label{fig:baza_danych_test}
\end{figure}

Jak zachowa siê baza danych przy próbie stworzenia alfabetycznego indeksu studentów, których nazwiska zaczynaj¹ siê na dan¹ literê (Listing \ref{listing:sql})?

\begin{lstlisting}[language=sql, caption=Zapytanie do wyœwietlenia menu ksi¹¿ki adresowej uczniów, label=listing:sql]
SELECT left(s.lastName, 1) letter, COUNT(s.id) students
FROM student s 
WHERE s.lastName > 'A'
GROUP BY letter
\end{lstlisting}

Rezultat dzia³ania zapytania SQL widoczny jest na listingu \ref{listing:sql_adresowa}. Jak widaæ zapytanie wykonuje siê w czasie 40 milisekund. Jest to dosyæ krótko, ale wynika to g³ownie z rozmiarów kolekcji danych (20244 studentów). Wraz z rozrastaniem siê tej tabeli, czas potrzebny na wykonanie tego zapytania bêdzie siê systematycznie powiêksza³. Dzieje siê tak, poniewa¿ tabela studentów nie posiada ¿adnego indeksu.

\begin{lstlisting}[caption=Wynik zapytania z listingu \ref{listing:sql}, label=listing:sql_adresowa]
+--------+----------+
| letter | students |
+--------+----------+
| A      |      999 |
| B      |     1749 |
| C      |      814 |
| D      |      670 |
| E      |      385 |
| F      |      918 |
| G      |     1599 |
| H      |      808 |
| I      |      245 |
| J      |      194 |
| K      |     1695 |
| L      |     1156 |
| M      |     1411 |
| N      |      492 |
| O      |      240 |
| P      |      686 |
| Q      |       14 |
| R      |     1259 |
| S      |     2662 |
| T      |      499 |
| U      |       57 |
| V      |      244 |
| W      |      698 |
| Y      |      316 |
| Z      |      400 |
+--------+----------+
25 rows in set (0.04 sec)

\end{lstlisting}

\subsubsection{Czym jest indeks?}

\textit{Indeks} jest struktur¹ danych przeznaczon¹ do pomocy systemowi baz danych w efektywnym pobieraniu informacji z tabel. S¹ one czêsto wymagane dla zapewnienia dobrej wydajnoœci. Indeksy s¹ szczególnie wa¿ne w momencie kiedy baza danych siê rozrasta, poniewa¿ iloœæ elementów do przeszukiwania wierszowego ulega zwielokrotnieniu.

Podczas zwyk³ego wyszukiwania wartoœci w bazie danych, program musi przeszukaæ ka¿d¹ kolumnê ka¿dego wiersza w poszukiwaniu okreœlonej wartoœci. W wypadku indeksów sprawa jest uproszczona, poniewa¿ dysponujemy pewnym podzbiorem wartoœci, na przyk³ad z danej kolumny lub wyra¿enia. W ten sposób silnik bazy danych wie, ¿e dana wartoœæ znaleziona w okreœlonym indeksie powi¹zana jest z okreœlonym rekordem, wiêc odpowiedŸ jest b³yskawiczna.

Oczywiœcie wykorzystywanie indeksów wi¹¿e siê równie¿ z dodatkow¹ alokacj¹ danych, poniewa¿ oprócz danych w tabeli, trzeba dodatkowo przechowywaæ dane indeksów. Przeliczaj¹c jednak zyski do strat, wiêkszoœæ przemawia za stosowaniem indeksów.

\subsection{Optymalizacja tabel przy u¿yciu indeksów}

Optymalizacja zapytañ przy u¿yciu indeksów jest stosunkowo prosta i polega na stworzeniu indeksu, który najlepiej pasuje do wyszukiwanej zawartoœci. W naszym wypadku potrzeba indeksu przechowuj¹cego pierwsz¹ literê nazwiska. Z drugiej strony sortowanie po nazwisku lub nawet wyszukiwanie po nim jest doœæ czêst¹ operacj¹, dlatego warto stworzyæ kompletny indeks dla pola \texttt{lastName} tabeli student (Listing \ref{fig:baza_danych_test}). Na podstawie wyniku uzyskanego w listingu \ref{listing:sql_adresowa2}, widaæ znaczn¹ poprawê czasu wykonywania. Wszystkie zapytania wykorzystuj¹ce kolumnê \texttt{lastName}, powinny wykonywaæ siê zdecydowanie szybciej. 

\begin{lstlisting}[caption=Utworzenie indeksu na polu \texttt{lastname} dla tabeli \texttt{student}]
ALTER TABLE `student` ADD INDEX `lastName_idx`(`lastName`);
\end{lstlisting}

\begin{lstlisting}[caption=Wynik zapytania z listingu \ref{listing:sql} po optymalizacji indeksu, label=listing:sql_adresowa2]
+--------+----------+
| letter | students |
+--------+----------+
| A      |      999 |
| B      |     1749 |
| C      |      814 |
| D      |      670 |
| E      |      385 |
| F      |      918 |
| G      |     1599 |
| H      |      808 |
| I      |      245 |
| J      |      194 |
| K      |     1695 |
| L      |     1156 |
| M      |     1411 |
| N      |      492 |
| O      |      240 |
| P      |      686 |
| Q      |       14 |
| R      |     1259 |
| S      |     2662 |
| T      |      499 |
| U      |       57 |
| V      |      244 |
| W      |      698 |
| Y      |      316 |
| Z      |      400 |
+--------+----------+
25 rows in set (0.01 sec)

\end{lstlisting}

\subsubsection{Kolejnoœæ z³¹czeñ}


\textit{Z³¹czenia} (ang. \textit{joins}) s¹ operacj¹ spajaj¹c¹ ze sob¹ dwie lub wiêcej tabel. Dopuszczalne s¹ ³¹czenia dwóch ró¿nych tabel lub tej samej tabeli (\textit{self-joins}). U¿ywanie z³¹czeñ wynika w du¿ej mierze z normalizacji bazy danych, a co za tym idzie usuniêcia nadmiarowoœci z rekordów tabeli. Takie podejœcie w du¿ej mierze poprawia spójnoœæ danych, ale równie¿ mo¿e pogorszyæ znacznie wydajnoœæ zapytañ.\\

\begin{lstlisting}[language=SQL, caption=Kilka mo¿liwych do wykorzystania \textit{z³¹czeñ} miêdzy tabel¹ \texttt{profile}\, a \texttt{student},label=listing:zapytania_profile]
SELECT SQL_NO_CACHE * FROM profile p inner join student s on s.profileId = p.id
SELECT SQL_NO_CACHE * FROM profile p left join student s on s.profileId = p.id
SELECT SQL_NO_CACHE * FROM profile p right join student s on s.profileId = p.id
SELECT SQL_NO_CACHE * FROM student s inner join profile p on s.profileId = p.id
SELECT SQL_NO_CACHE * FROM student s left join profile p on s.profileId = p.id
SELECT SQL_NO_CACHE * FROM student s right join profile p on s.profileId = p.id
\end{lstlisting}

Standard ANSI wyró¿nia cztery rodzaje z³¹czeñ: INNER, OUTER, LEFT, RIGHT. W specjalnych okolicznoœciach tabela mo¿e byæ równie¿ po³¹czona sama ze sob¹. Zasadnicza ró¿nica w specyfice polega na kryterium ³¹czenia - w wypadku \textit{INNER JOINÓW} wymagane jest istnienie odpowiadaj¹cych sobie krotek po dwóch stronach relacji, natomiast \textit{OUTER JOIN} wymaga spe³nienia tego kryterium przynajmniej po jednej stronie relacji - odpowiednio lewej lub prawej. 

Ró¿nice miêdzy z³¹czeniami przek³adaj¹ siê równie¿ na wydajnoœæ dzia³ania. Najpopularniejsze ze z³¹czeñ \textit{inner join'y} s¹ najszybsze, podczas gdy pozosta³e przeznaczone s¹ do bardziej specyficznych zastosowañ.

Kolejny z przeprowadzanych testów, bêdzie polega³ na z³¹czeniu ze sob¹ studentów oraz profili, innymi s³owy wyœwietleniu wszystkich studentów przynale¿nych do któregoœ z profili. Wynik dzia³ania poszczególnych testów (Listing \ref{listing:zapytania_profile}) zosta³ zestawiony w tabeli \ref{table:3_sql}. Wyniki zapytañ stanowi¹ potwierdzenie ogólnie przyjêtych zasad optymalizacji zapytañ - \textit{inner join} okaza³ siê najszybszym ze z³¹czeñ. Jednoczeœnie widaæ, ¿e kolejnoœæ wykonywania z³¹czeñ równie¿ ma wp³yw na wydajnoœæ. Zazwyczaj powinno siê zaczynaæ od tabeli, która posiada miej rekordów (w tym wypadku tabela profile). Ogromna ró¿nica miêdzy czasem wykonywania \textit{left join} oraz \textit{right join} w odwrotnej kolejnoœci ³¹czenia wynika z braku indeksu dla pola \texttt{profileId} tabeli \texttt{student}. Po dodaniu indeksów widaæ 10-krotn¹ poprawê szybkoœci wykonywania tego zapytania.\\

\begin{table}\centering
\caption{Tabela z rezultatem dzia³ania poszczególnych zapytañ}
\begin{tabular}{@{}rrrrcrrrcrrr@{}}\toprule
Typ & Czas wykonywania [sec] & Iloœæ rekordów \\
\bottomrule
\texttt{inner join student} & 0.2557 & 20244\\
\texttt{left join student}  & {\color{red}\textbf{5.2125 / 0.5635}} & 20463\\
\texttt{right join student} & 0.2634 & 20244\\
\bottomrule
\texttt{inner join profile} & 0.2726 & 20244\\
\texttt{left join profile}  & 0.3272 & 20463\\
\texttt{right join profile} & {\color{red}\textbf{5.2236 / 0.5704}} & 20463
\end{tabular}
\label{table:3_sql}
\end{table}

\subsection{Wykorzystanie polecenia \texttt{EXPLAIN} do optymalizacji zapytañ.}

Przedstawione dotychczas przypadki by³y stosunkowo proste do naprawy. 
Czêsto jednak zapytania s¹ du¿o bardziej rozbudowane i trudniejsze do szybkiej dekompozycji. Warto wtedy skorzystaæ z udostêpnianego przez MySQL narzêdzia \texttt{EXPLAIN}. Oferuje on pomoc w zakresie dekompozycji bardziej skomplikowanych zapytañ. Narzêdzie to pokazuje miêdzy innymi wykorzystane klucze dla ³¹czeñ, liczebnoœæ ³¹czonych tabel, proponowane usprawnienia indeksów.

Jednym z zapytañ, które mo¿e stanowiæ potencjalny problem w analizie, jest zapytanie zaczerpniête z istniej¹cej aplikacji, opartej o przedstawiony na rysunku \ref{fig:baza_danych_test} diagram \textit{ERD}. Przedstawione na listingu \ref{listing:sql_dlugie} zapytanie wyœwietla szczegó³owe statystyki liczebnoœci, punktacji opartej o zsumowane wartoœci obecnoœci na danych zajêciach, a tak¿e statystyki uczêszczanych programów, praktyk oraz wielu innych specjalistycznych kategorii. 

Omawiane zapytanie jest prawdopodobnie jednym z trudniejszych, na jakie mo¿na kiedykolwiek trafiæ podczas analizy bazodanowej. G³ównym problemem takich zapytañ jest istnienie wielu powi¹zanych z nim \textit{podzapytañ skorelowanych}, czyli takich, których wynik zale¿y od zapytania g³ównego. W celu analitycznej analizy tego zapytania u¿yto narzêdzie \texttt{EXPLAIN}. Sk³adnia tej dyrektywy jest prosta i polega na dodaniu jej na pocz¹tku wczeœniejszego zapytana. Wynik takiego zapytania zwróci iloœæ wierszy równ¹ iloœci wszystkich podzapytañ wykonywanych w trakcie przetwarzania (Tabela \ref{table:4_explain}).\\

Na podstawie tabeli \ref{table:4_explain}  widaæ, ¿e na wynik zapytania sk³adaj¹ siê rezultaty ³¹cznie 21 mniejszych zapytañ. Za ka¿dym razem, kiedy z³¹czamy jedn¹ tabelê z drug¹ lub wykonujemy zapytanie wewnêtrzne albo skorelowane, iloœæ pracy do wykonania ulega zwiêkszeniu. Otrzymane zapytanie zawiera informacje podzielone na szeœæ kolumn. Ka¿da z nich ma inne znaczenie i prezentuje okreœlon¹ cechê badanego fragmentu zapytania \cite{book:mysql_explain}.


\begin{lstlisting}[caption=Bardziej rozbudowane zapytanie SQL, language=SQL, label=listing:sql_dlugie]
SELECT o.id, o.name,

(SELECT group_concat(oc.campusId SEPARATOR ' ' ) FROM organizationCampus oc WHERE oc.organizationId = o.id) as campusIds,

(SELECT count(s5.id)
FROM profile p5
INNER JOIN student s5 on s5.profileId = p5.id
WHERE p5.organizationId = o.id) as students,

IFNULL((SELECT count(DISTINCT s3.id)
FROM profile p3 
INNER JOIN student s3 on p3.id = s3.profileId
INNER JOIN studentIntensiveProgram sip on sip.studentId = s3.id
WHERE p3.organizationId = o.id
GROUP BY p3.organizationId
),0) as programs,

IFNULL((SELECT round(SUM(classes*1 + 1on1*3 + shabbaton*5 + socialEvents*0.5 + shabbosMeals*2)) 
FROM
student s2
INNER JOIN profile p2 on p2.id = s2.profileId 
INNER JOIN `reportStudentAttendance` AS `r1` ON r1.studentId = s2.id 
INNER JOIN `report` AS `ra` 
ON ra.id = r1.reportId 
and ((ra.month >= 9 and ra.year = 2011) or (ra.month <=8 and ra.year = 2012))
WHERE p2.organizationId = o.id 
GROUP BY p2.organizationId ), 0) as score,

(SELECT ifnull(sum(datediff("2012-08-30", sy.startDate) BETWEEN 30 and 90 
      and sy.startDate between "2011-09-01" and "2012-08-30"),0)
FROM profile p4
INNER JOIN student s4 on s4.profileId = p4.id
INNER JOIN studentYeshiva sy on sy.studentId = s4.id
WHERE p4.organizationId = o.id) as yeshiva_1_3,

(SELECT ifnull(sum(datediff("2012-08-30", sy.startDate) BETWEEN 91 and 180 
      and sy.startDate between "2011-09-01" and "2012-08-30"),0)
FROM profile p4
INNER JOIN student s4 on s4.profileId = p4.id
INNER JOIN studentYeshiva sy on sy.studentId = s4.id
WHERE p4.organizationId = o.id) as yeshiva_4_6,

(SELECT ifnull(sum(datediff("2012-08-30", sy.startDate) > 181 
      and sy.startDate > 2000),0)
FROM profile p4
INNER JOIN student s4 on s4.profileId = p4.id
INNER JOIN studentYeshiva sy on sy.studentId = s4.id
WHERE p4.organizationId = o.id) as yeshiva_6,

IFNULL((SELECT sum(case 
when s1.beganSo = "spring/2011" then "2011-01-01"
when s1.beganSo = "summer/2011" then "2011-05-01"
when s1.beganSo = "fall/2011" then "2011-09-01"
else "2012-08-30"
end >= "2011-09-01" and right(s1.beganSo, 4) >= 2011 and s1.beganSo != "before") 
FROM student s1
INNER JOIN profile p1 on s1.profileId = p1.id
WHERE p1.organizationId = o.id
GROUP BY o.id),0) AS `so`
FROM organization o
GROUP BY o.id
HAVING score > 0
ORDER BY o.name
\end{lstlisting}

\subsubsection{Opis pól wynikowych polecenia \texttt{EXPLAIN}.}

\begin{description}
\item[id]
Okreœla numer porz¹dkowy zapytania w kontekœcie planu wykonywania.

\item[select\_type] 
Okreœla u¿yty rodzaj zapytania. Dostêpne wartoœci to:\\
\texttt{PRIMARY} - zapytanie g³ówne.\\
\texttt{UNION} (zapytanie typu \texttt{UNION}, drugie lub dalsze zapytanie w kolejnoœci, polegaj¹ce na dodanie rezultatu jednego zapytania do drugiego, bez wyró¿nienia kryteriów ³¹czenia).\\
\texttt{DEPENDENT UNION} zale¿y dodatkowo od zapytania g³ównego.\\
\texttt{SUBQUERY} - pierwsze u¿ycie \texttt{SELECT} w podzapytaniu.\\
\texttt{DEPENDENT SUBQUERY} - podobnie, jak w poprzednim przypadku, ale zale¿y od zapytania g³ównego.\\
\texttt{DERIVED} - podzapytanie umieszczone w sekcji \texttt{FROM}.\\ \texttt{UNCACHEABLE SUBQUERY / UNION} to dwa najgorsze typy zapytania, poniewa¿ ich wynik musi byæ wykonywany dla ka¿dego wiersza g³ównego zapytania osobno.

\item[table] Odnosi siê do nazwy tabeli lub aliasu aktualnie przetwarzanego zapytania.

\item[type] Rodzaj zasobu u¿ytego do z³¹czenia, najpopularniejsze wartoœci to:\\ \texttt{system} (z³¹czenie z systemow¹ tabel¹, posiadaj¹c¹ jeden wiersz, specjalna odmiana z³¹czenia \texttt{const}), najszybszy rodzaj z³¹czenia, ale ma³o jest praktycznych zastosowañ.

\texttt{Const} - z³¹czana tabela ma co najwy¿ej jeden pasuj¹cy element, przez co pobierana jest tylko raz, przez co wiersz jest traktowany jako sta³a. Dotyczy porównania pewnej sta³ej wartoœci z \textbf{pe³n¹} wartoœciami \textit{klucza g³ównego} lub unikalnego indeksu.

\texttt{Eq\_ref} jest dostêpny w sytuacjach, kiedy porównujemy wartoœci z indeksów przy pomocy operatora "\texttt{=}" i istnieje dok³adnie jedna wartoœæ do pobrania dla ka¿dego klucza z tabeli ³¹cz¹cej. Przyrównana wartoœæ mo¿e byæ sta³¹ lub wczeœniej wczytan¹ kolumn¹ innej tabeli. Kiedy istnieje wiêcej ni¿ jedna wartoœæ dla danego klucza tabeli ³¹cz¹cej, to wtedy mamy do czynienia z typem \texttt{ref}.

\texttt{Ref} wystêpuje równie¿ wtedy, kiedy wykorzystano operatory "\texttt{<=>}". Inn¹ odmian¹ \texttt{ref} jest \texttt{ref\_or\_null}, wystêpuj¹ce wówczas, gdy szukano równie¿ wierszy które s¹ równe wartoœci \texttt{null}.

\texttt{ALL} - najgorszy mo¿liwy przypadek z³¹czenia. Ca³a tabela jest przetwarzana i tworzone s¹ wszystkie kombinacje wartoœci z tabeli ³¹cz¹cej. Trochê lepsza sytuacja jest w wypadku \texttt{INDEX}, kiedy to zapytanie wykorzystuje kolumny, które s¹ czêœci¹ pojedynczego indeksu.

\item[possible\_keys] Pokazuje proponowane klucze, które mo¿na wykorzystaæ podczas ³¹czenia. W praktyce nie wszystkie z nich mo¿na faktycznie u¿yæ.

\item[key] Wykorzystane do ³¹czenia klucze. Jeœli to pole jest puste, podobnie jak poprzednie, to wskazówka, ¿e nale¿y dodaæ indeks.

\end{description}

Na podstawie dokonanej analizy, widaæ, ¿e dla podzapytania nr 2 wystêpuje rodzaj z³¹czenia typu \texttt{index}. Oznacza to, ¿e mo¿na je usprawniæ dodaj¹c indeks szczegó³owy. Poniewa¿ tabela \texttt{organizationCampus}, do której odnosi siê alias \texttt{oc} jest tabel¹ ³¹cznikow¹, to jest tam u¿yty klucz g³ówny z³¹czony. Dlatego te¿ tylko czêœæ tego indeksu jest wykorzystana. Po dodaniu szczegó³owego indeksu na pole \texttt{organizationId}, osi¹gniêto po¿¹dany typ \textit{ref}, a czas wykonywania zapytania zredukowa³ siê o 40ms (Tabela \ref{table:4_explain}).

\begin{sidewaystable}
\caption{Wynik dzia³ania polecenia \texttt{EXPLAIN}}
\begin{tabular}{@{}rrrrcrrrcrrr@{}}
\toprule
\textbf{id} & \textbf{select\_type} & \textbf{table} & \textbf{type} & \textbf{possible\_keys} & \textbf{key} \\ \bottomrule
\textit{1} & \textit{PRIMARY} & o & ALL &  &  \\
\textit{9} & \textit{DEPENDENT SUBQUERY} & p1 & ref & PRIMARY,organizationId & organizationId \\
\textit{9} & \textit{DEPENDENT SUBQUERY} & s1 & ref & profile\_idx & profile\_idx \\
\textit{8} & \textit{DEPENDENT SUBQUERY} & p4 & ref & PRIMARY,organizationId & organizationId \\
\textit{8} & \textit{DEPENDENT SUBQUERY} & s4 & ref & PRIMARY,profile\_idx & profile\_idx \\
\textit{8} & \textit{DEPENDENT SUBQUERY} & sy & ref & studentIdx & studentIdx \\
\textit{7} & \textit{DEPENDENT SUBQUERY} & p4 & ref & PRIMARY,organizationId & organizationId \\
\textit{7} & \textit{DEPENDENT SUBQUERY} & s4 & ref & PRIMARY,profile\_idx & profile\_idx \\
\textit{7} & \textit{DEPENDENT SUBQUERY} & sy & ref & studentIdx & studentIdx \\
\textit{6} & \textit{DEPENDENT SUBQUERY} & p4 & ref & PRIMARY,organizationId & organizationId \\
\textit{6} & \textit{DEPENDENT SUBQUERY} & s4 & ref & PRIMARY,profile\_idx & profile\_idx \\
\textit{6} & \textit{DEPENDENT SUBQUERY} & sy & ref & studentIdx & studentIdx \\
\textit{5} & \textit{DEPENDENT SUBQUERY} & p2 & ref & PRIMARY,organizationId & organizationId \\
\textit{5} & \textit{DEPENDENT SUBQUERY} & s2 & ref & PRIMARY,profile\_idx & profile\_idx \\
\textit{5} & \textit{DEPENDENT SUBQUERY} & r1 & ref & student\_idx,report\_idx & student\_idx \\
\textit{5} & \textit{DEPENDENT SUBQUERY} & ra & eq\_ref & PRIMARY,month\_idx,year\_idx & PRIMARY \\
\textit{4} & \textit{DEPENDENT SUBQUERY} & p3 & ref & PRIMARY,organizationId & organizationId \\
\textit{4} & \textit{DEPENDENT SUBQUERY} & s3 & ref & PRIMARY,profile\_idx & profile\_idx \\
\textit{4} & \textit{DEPENDENT SUBQUERY} & sip & ref & student\_idx & student\_idx \\
\textit{3} & \textit{DEPENDENT SUBQUERY} & p5 & ref & PRIMARY,organizationId & organizationId \\
\textit{3} & \textit{DEPENDENT SUBQUERY} & s5 & ref & profile\_idx & profile\_idx \\
\textit{2} & \textit{DEPENDENT SUBQUERY} & oc & index &  & PRIMARY
\end{tabular}
\label{table:4_explain}
\end{sidewaystable}

\subsection{Optymalizacja definicji tabel}

Nie bez znaczenia dla ogólnej wydajnoœci aplikacji jest równie¿ wykorzystanie w³aœciwych dla przechowywanych treœci typów pól. Istnieje szereg regu³ pomocnych w tworzeniu zoptymalizowanych schematów danych. S¹ to regu³y niezale¿ne od wykorzystanego systemu baz danych.

\begin{description}
\item[Ma³e znaczy lepsze] Zazwyczaj nale¿y wykorzystywaæ mo¿liwie najmniejszy typ danych, który jest w stanie prawid³owo przechowaæ powierzone dane. Mniejsze typy danych s¹ szybsze, poniewa¿ zu¿ywaj¹ mniej miejsca na dysku, w pamiêci i w pamiêci podrêcznej procesora. Dodatkowo, mniejsza iloœæ cykli procesora jest potrzebna do ich przetworzenia.
\item[Proste typu s¹ wydajniejsze] Podobnie, jak w poprzednim przyk³adzie, proste typy danych wymagaj¹ mniejszych nak³adów pracy procesora do przetworzenia. Dla porównania, typ ca³kowity jest szybszy ni¿ typ znakowy. Dzieje siê tak, poniewa¿ razem ze znakiem powi¹zane s¹ informacje o kodowaniu oraz tzw. \textit{collations}, czyli regu³ach sortowania. Inne wa¿ne przyk³ady dotycz¹ na przyk³ad przechowywania daty i godziny w dedykowanych typach danych, zamiast typu ³añcuchowego. Z drugiej strony, adres IP powinien byæ przechowywany jako liczba ca³kowita \cite{book:proPHPProg}.
\item[Unikanie wartoœci \texttt{NULL}] Tak czêsto, jak to tylko mo¿liwe, pola tabeli powinny byæ definiowane jako \texttt{NOT NULL}. Niejednokrotnie schematy baz danych przechowuj¹ wartoœæ \texttt{NULL}, nawet jeœli tego nie potrzebuj¹. Nale¿y mieæ na uwadze, ¿e optymalizator zapytañ du¿o gorzej radzi sobie z takimi kolumnami, poniewa¿ sprawiaj¹ one ¿e indeksy, ich statystyki i porównywanie z wartoœciami jest bardziej skomplikowane. Nawet, jeœli  konieczne jest odnotowanie w polu pustej wartoœci, lepiej u¿yæ jakiegoœ arbitralnego symbolu na przyk³ad "0" lub pustego ³añcucha znakowego.
\end{description}

Dodatkowo, istnieje kilka przes³anek, dotycz¹cych wykorzystywania pól typu \texttt{VARCHAR} i \texttt{CHAR}. Zazwyczaj lepiej jest wykorzystywaæ typ \texttt{VARCHAR} (typ znakowy o zmiennej d³ugoœci), kiedy maksymalna szerokoœæ kolumny jest du¿o wiêksza ni¿ wartoœæ œrednia, a iloœæ aktualizacji tego pola jest ma³a, przez co fragmentacja nie jest problemem.  Nie bez znaczenia jest te¿ wybrane kodowanie. W standardzie \textit{UTF-8} ka¿dy znak wykorzystuje ró¿n¹ wartoœæ bajtów przestrzeni dyskowej.

Typ \texttt{CHAR} z kolei najlepiej spisuje siê w sytuacjach, kiedy przechowywane maj¹ byæ bardzo krótkie ³añcuchy lub ka¿dy ³añcuch jest praktycznie takiej samej d³ugoœci. Dla przyk³adu, \texttt{CHAR} jest dobrym wyborem do przechowywania zahaszowanych wartoœci hase³ u¿ytkowników. W odró¿nieniu od \texttt{VARCHAR}, ten typ danych nie ulega fragmentacji ze wzglêdu na sta³¹ szerokoœæ pola.

Inn¹ cenn¹ rad¹ jest stosowanie pól wyliczeniowych \texttt{ENUM}, jeœli zbiór dostêpnych wartoœci znakowych pola jest sta³y i nie bêdzie podlega³ póŸniejszym zmianom (wartoœæ zbioru, mo¿na jednak modyfikowaæ poleceniem \texttt{ALTER} analogicznie jak inne modyfikacje schematu). 

\section{Podsumowanie}
W ramach pierwszego rozdzia³u zosta³y przedstawione podstawowe metody optymalizacji aplikacji WWW. Omówienie mia³o na celu ogólne wprowadzenie w tematykê analizy oprogramowania, dzia³aj¹cego w sieci. Istnieje wiele technik optymalizacji \textit{front-endu}, baz danych lub serwera WWW. Wiêkszoœæ z nich jest dostosowana do konkretnych problemów wydajnoœciowych lub skonfigurowanej infrastruktury. Omówione zagadnienia s¹ jednak na tyle ogólne, ¿e mo¿na je odnieœæ z powodzeniem do aplikacji w dowolnym jêzyku programowania, a tak¿e dowolnym silniku bazodanowym. Znaj¹c jednak podstawy, z powodzeniem mo¿na wykonaæ dalsze etapy optymalizacji na w³asn¹ rêkê. Przedstawione porady zapewni¹ natomiast solidny fundament tworzonej aplikacji.

Kolejny rozdzia³ ma na celu przedstawienie architektury tworzonego oprogramowania. Bêdzie to rozwiniêcie o praktyczne wskazówki powy¿szego rozdzia³u dotycz¹cego optymalizacji serwera WWW.