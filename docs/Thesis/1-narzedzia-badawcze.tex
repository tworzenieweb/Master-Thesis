\chapter{Analiza jakoœciowa i wydajnoœciowa aplikacji}

Projektuj¹c aplikacje, ju¿ fazy projektowej, nale¿y myœleæ o zapewnieniu wysokiej wydajnoœci, a tak¿e o potencjalnych problemach, które mog¹ siê pojawiæ po wdro¿eniu oprogramowania. W celu zapewnienia tworzonej aplikacji najwy¿szej skutecznoœci pracy, nale¿y wzi¹æ pod uwagê wiele cech, wœród których najwa¿niejsze zdefiniowane s¹ poni¿ej.

\begin{description}
\item[Skalowalnoœæ (ang. \textit{Scalability})] cecha aplikacji, okreœlana jako zdolnoœæ do wzrostu wydajnoœci aplikacji. Wraz ze zwiêkszeniem iloœci dostêpnych zasobów sprzêtowych (serwery WWW, bazy danych, wydajniejsze procesory).

\item[Niezawodnoœæ (ang. \textit{High availability})] stanowi projekt, jak i odpowiedni¹ implementacje systemu, zapewniaj¹ca okreœlony poziom ci¹g³oœci wykonywania operacji w czasie. Polega to na zapewnieniu jak najwiêkszej dostêpnoœci us³ugi.

\item[Wydajnoœæ (ang. \textit{Performance})] przek³ada siê na mo¿liwoœæ faktycznego obs³u¿enia du¿ego ruchu sieciowego, przy jednoczesnym utrzymaniu czasu odpowiedzi aplikacji na stosownym poziomie.
\end{description}

Czêsto skalowalnoœæ jest mylona z wydajnoœci¹, jednak przek³adaj¹c to na bardziej ¿yciowy przyk³ad, wydajnoœæ aplikacji mo¿na porównaæ do szybkiego samochodu. Z drugiej strony, bez zapewnienia odpowiednich dróg, ten szybki samochód lub ich grupa, nie jest w stanie rozwin¹æ maksymalnej prêdkoœci. W najgorszym wypadku mo¿e nawet utkwiæ w korku, blokowany przez inne pojazdy. 
Skalowalnoœæ jest wiêc zapewnieniem \textbf{odpowiedniej infrastruktury} gwarantuj¹cej w³aœciwy rozrost systemu.\\

W celu zapewnienia mo¿liwie najlepszej jakoœci tworzonej aplikacji, nale¿y stale monitorowaæ aktualny poziom wydajnoœci aplikacji. Nale¿y jednak mieæ na uwadze, ¿e na wydajnoœæ aplikacji sk³ada siê czas przetwarzania poszczególnych wêz³ów systemu. Nale¿y wiêc testowaæ ka¿de z nich osobnymi metodami, omówionymi w dalszej czêœci pracy.

Szukaj¹c przyczyn b³êdów, warto rozpocz¹æ analizê od najbardziej ogólnego komponentu czyli serwera WWW odpowiedzialnego za wysy³anie odpowiedzi na ¿¹danie u¿ytkownika. Nastêpnie nale¿y dokonaæ dekompozycji, wyró¿niaj¹c kolejne wêz³y systemu, takie jak dalsze instancje serwera WWW czy serwery bazodanowe.

\section{Analiza wydajnoœci serwera WWW}

Zadaniem serwera WWW jest wys³anie do inicjatora ¿¹dania wyniku przetwarzania zasobu okreœlonego adresem URL. W najprostszym wypadku, analiza wydajnoœci serwera, polega na odpytaniu go o okreœlony zasób i zmierzenie czasu od rozpoczêcia tej akcji, do odebrania rezultatu. Taki proces mo¿ma przeœledziæ i przeanalizowaæ w wiêkszoœci popularnych przegl¹darek np. Google Chrome, które jest wyposa¿one w wiele przydatnych narzêdzi analitycznych (Rys. \ref{fig:rys1_chrome}).

\begin{figure}[htbp]
\caption{Analiza czasu wykonywania strony http://ftims.edu.p.lodz.pl// wykonana w przegl¹darce Google Chrome}
\label{fig:rys1_chrome}
\includegraphics[scale=0.71]{rys1_chrome.pdf}
\end{figure}

Taki sposób analizy, jest jednak przydatny jedynie w wypadku znacznych problemów z wydajnoœci¹ aplikacji, poniewa¿ testowanie czasu odpowiedzi dla pojedynczego u¿ytkownika, wykonuj¹cego pojedyncze ¿¹danie, nie jest w ¿adnym stopniu miarodajne.\\

W celu zapewnienia bardziej rzetelnego testu, nale¿y skorzystaæ z dedykowanych rozwi¹zañ takich jak \texttt{ab} oraz \texttt{siege}. 
S¹ to typowe narzêdzia przeznaczone do sprawdzania jak dobrze serwer radzi sobie z obs³ug¹ bardziej z³o¿onego ruchu sieciowego. 
Przyk³adowo, dla wczeœniej u¿ytej strony, mo¿na zasymulowaæ ruch równy wykonaniu 10 jednoczesnych ¿¹dañ przez 10 niezale¿nych u¿ytkowników. 
W tym celu nale¿y wydaæ komendê \lstinline{ab -n 10 -c 10 http://ftims.edu.p.lodz.pl/}. Rezultat dzia³ania komendy widoczny jest na listingu \ref{listing:ab}.

\begin{lstlisting}[caption=Analiza strony z wykorzystaniem narzêdzia \texttt{ab}, label=listing:ab]
Server Software:        Apache/2.2.14
Server Hostname:        ftims.edu.p.lodz.pl
Server Port:            80

Document Path:          /
Document Length:        48759 bytes

Concurrency Level:      10
Time taken for tests:   0.695 seconds
Complete requests:      10
Failed requests:        0
Write errors:           0
Total transferred:      492510 bytes
HTML transferred:       487590 bytes
Requests per second:    14.38 [#/sec] (mean)
Time per request:       695.270 [ms] (mean)
Time per request:       69.527 [ms] (mean, across all concurrent requests)
Transfer rate:          691.77 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       52   63   7.4     63      74
Processing:   300  503  90.9    532     632
Waiting:      127  233  62.8    235     381
Total:        354  565  92.9    593     695

Percentage of the requests served within a certain time (ms)
  50%    593
  66%    612
  75%    625
  80%    628
  90%    695
  95%    695
  98%    695
  99%    695
 100%    695 (longest request)

\end{lstlisting}

Jak mo¿na wywnioskowaæ z powy¿szych danych, narzêdzie wykonuje wiele przydatnych analiz, a tak¿e wyœwietla informacje o badanym zasobie. 
Widaæ przede wszystkim, ¿e czas oczekiwania na stronê przy 10 u¿ytkownikach jest prawie trzykrotnie d³u¿szy, ni¿ podczas jednego ¿¹dania wykonanego w przegl¹darce (\ref{fig:rys1_chrome}). 

Oczywiœcie na wyniki pomiarów ma tak¿e wp³yw prêdkoœæ po³¹czenia internetowego, dlatego w celu pominiêcia dodatkowych czynników, testy docelowej aplikacji bêd¹ wykonywane przede wszystkim na lokalnym serwerze. 
Najbardziej miarodajn¹ jednostk¹ okreœlaj¹c¹ wydajnoœæ aplikacji w wypadku narzêdzia \textit{ab} jest liczba zapytañ na sekundê (\textit{req/s}). 
Okreœla ona maksymaln¹ iloœæ ¿¹dañ w jednostce czasu, jak¹ aplikacja jest w stanie obs³u¿yæ. Oczywiœcie im wiêksza wartoœæ, tym lepsza ogólna wydolnoœæ aplikacji.\\

Na rysunku \ref{fig:rys2_http_lifecycle} przedstawiono cykl ¿ycia ¿¹dania od u¿ytkownika je inicjuj¹cego, koñcz¹c na odebraniu odpowiedzi serwera. Jak mo¿na zauwa¿yæ ¿¹danie przebywa stosunkowo d³ug¹ drogê, nim trafi do faktycznej aplikacji. Wynikiem tego s¹ dodatkowe opóŸnienia zale¿ne od stopnia skomplikowania architektury trzech pierwszych wêz³ów. 
Dlatego te¿ nale¿y mieæ na uwadze, ¿e problemy z szybkoœci¹ dzia³ania aplikacji nie musz¹ le¿eæ wy³¹cznie po stronie aplikacji lub serwera. 
Do najbardziej popularnych nale¿¹: niska przepustowoœæ ³¹cza internetowego klienta, wolny serwer DNS, daleka lokalizacja geograficzna serwera WWW, Ÿle skonfigurowany router lub bardzo obci¹¿ona sieæ lokalna.

\begin{figure}[htbp]
\includegraphics[scale=0.55]{fig_request.pdf}
\caption{Cykl ¿ycia ¿¹dania}
\label{fig:rys2_http_lifecycle}
\end{figure}

Nawi¹zuj¹c do listingu \ref{listing:ab}, wartoœciami zwi¹zanymi ze wspomnianymi w poprzednim akapicie wêz³ami s¹ \texttt{Connect} oraz \texttt{Waiting}, czyli odpowiednio czas oczekiwania na po³¹czenie z zasobem i czas pobierania odpowiedzi z zasobu. Istnieje 5 g³ównych czynników wp³ywaj¹cych na czas odpowiedzi serwera.

\begin{description}

\item[Po³o¿enie geograficzne i problemy z sieci¹ komputerow¹.]

Nie bez znaczenia dla czasu odpowiedzi, jaki u¿ytkownik odczuwa jest te¿ lokalizacja serwerów stron. Jeœli serwery s¹ zlokalizowane w USA, a u¿ytkownicy odwiedzaj¹cy stronê s¹ np. z Europy, dystans jaki musi pokonaæ ¿¹danie od momentu dotarcia do zasobu, oczekiwania, a¿ do jego pobrania jest nie wspó³miernie wiêkszy ni¿ w wypadku stron hostowanych dla tego samego po³o¿enia geograficznego. 
Stopieñ opóŸnienia jest zazwyczaj uzale¿niony od iloœci routerów, serwerów poœrednich, a nawet oceanów, które pokonuje ¿¹danie od punktu pocz¹tkowego do odbiorcy i z powrotem.

\item[Wielkoœæ dokumentu odpowiedzi serwera.] Zale¿noœæ miêdzy wielkoœci¹ dokumentu, a czasem odpowiedzi serwera jest oczywista, ³atwo wiêc sprawdziæ, ¿e im wiêkszy dokument trzeba pobraæ, tym wiêcej czasu potrzeba na zakoñczenie tego procesu.

\item[Wykonywanie kodu aplikacji.] Najczêstsza przyczyna wolnego dzia³ania aplikacji wynika w³aœnie z braku optymalizacji kodu klienta. D³ugi czas wykonywania kodu aplikacji implikuje, d³ugi czas ³¹czny oczekiwania na odpowiedŸ serwera. Problem ten zostanie szczegó³owiej poruszony w rozdziale \ref{cha:optymalizacja_aplikacji}.

\item[Rodzaj u¿ytej przegl¹darki.] Nie bez znaczenia dla ogólnego czasu ³adowania strony jest równie¿ rodzaj u¿ytej przegl¹darki. Czêsto wbudowane w przegl¹darkê wewnêtrzne mechanizmy buforowania zasobów pozwalaj¹ w znaczny sposób zredukowaæ iloœæ zapytañ wysy³anych do serwera. Dotyczy to zw³aszcza danych statycznych takich jak arkusze CSS, pliki JavaScript czy zasoby graficzne, które nie zmieniaj¹ siê zbyt czêsto. 

\item[Konfiguracja serwera WWW.] W zale¿noœci od u¿ytej technologii, istnieje wiele ró¿nych serwerów HTTP. Wœród najczêœciej u¿ywanych, prym wiedzie serwer HTTP \textit{Apache}. 
Dla rozwi¹zañ napisanych w technologii Java czêsto wykorzystywane s¹ serwery \textit{GlassFish}, \textit{Tomcat}, \textit{Jetty}. W wiêkszoœci wypadków zaraz po instalacji, oprogramowanie serwera nie nadaje siê jeszcze do wykorzystania w produkcji. 
Nale¿y wywa¿yæ ustawienia serwera do bie¿¹cych potrzeb, poniewa¿ w wiêkszoœci wypadków domyœlne ustawienia mog¹ znacznie obni¿yæ ogóln¹ wydajnoœæ. 
Innym wa¿nym dzia³aniem jest dostosowywanie serwera do konkretnych zastosowañ - do serwowania plików statycznych lepszym rozwi¹zaniem jest wykorzystanie bardziej oszczêdnego pamiêciowo i operacyjnie serwera \textit{Ngnix}, natomiast do bardziej zaawansowanych zastosowañ, w tym wykonywanie kodu aplikacji, serwera Apache lub osobnej instancji serwera \textit{Ngnix}.

\end{description}

Administratorzy serwerów WWW maj¹ bezpoœredni dostêp do statystyk odwiedzalnoœci stron, przez co pozwala to zaobserwowaæ pewne trendy odwiedzin u¿ytkowników. 
Czêsto jest tak, ¿e dane zasoby s¹ du¿o intensywniej odpytywane przez u¿ytkowników np. w czasie 10 minut stronê odwiedza 100 u¿ytkowników. 
£atwo to sobie wyobraziæ np. w wypadku premiery jakiejœ nowej gry, lub publikacji wyników egzaminu na uczelni. 
Taki periodyczny, lecz bardzo wzmo¿ony ruch mo¿e powodowaæ pewne trudne do ustalenia problemy z dzia³aniem aplikacji. Dlatego te¿ twórcy narzêdzia \texttt{ab}, zaimplementowali równie¿ mo¿liwoœæ testów czasowych (ang. \textit{timed tests}). W ten sposób mo¿na zasymulowaæ jak strona bêdzie siê zachowywa³a równie¿ w takich nag³ych wypadkach.\\

Wydaj¹c komendê \lstinline{ab -c 10 -t 30 http://ftims.edu.p.lodz.pl/}, mo¿na sprawdziæ, jak zachowa siê aplikacja odwiedzana przez 10 u¿ytkowników jednoczeœnie w czasie 30 sekund. Ta komenda pozbawiona jest parametru \textit{-t iloœæ ¿¹dañ}, oznacza to ¿e symulacja zakoñczy siê po 30 sekundach lub po osi¹gniêciu limitu 50 000 ¿¹dañ.

\begin{lstlisting}[caption=Test obci¹¿enia czasowego, label=listing:ab_2]
Benchmarking ftims.edu.p.lodz.pl (be patient)
Finished 504 requests

Server Software:        Apache/2.2.14
Server Hostname:        ftims.edu.p.lodz.pl
Server Port:            80

Document Path:          /
Document Length:        48759 bytes

Concurrency Level:      10
Time taken for tests:   40.180 seconds
Complete requests:      504
Failed requests:        0
Write errors:           0
Total transferred:      24822504 bytes
HTML transferred:       24574536 bytes
Requests per second:    12.54 [#/sec] (mean)
Time per request:       797.213 [ms] (mean)
Time per request:       79.721 [ms] (mean, across all requests)
Transfer rate:          603.31 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       48   65  14.3     61     145
Processing:   284  436 288.9    376    2957
Waiting:      119  199 281.5    151    2660
Total:        333  500 287.8    439    3007

Percentage of the requests served within a certain time (ms)
  50%    439
  66%    458
  75%    477
  80%    493
  90%    563
  95%    666
  98%   1420
  99%   2142
 100%   3007 (longest request)

\end{lstlisting}

Listing \ref{listing:ab_2} przedstawia wynik testów czasowych. Najwa¿niejsz¹ informacj¹ z punktu widzenia optymalizacji jest iloœæ ¿¹dañ na sekundê, która w tym wypadku wynosi \texttt{12.54}. Narzêdzie \texttt{ab} pozwala równie¿ zdiagnozowaæ potencjalne b³êdy aplikacji pod wp³ywem zbyt du¿ego ruchu. 
Pola takie jak \texttt{Failed requests} oraz \texttt{Write errors} u³atwiaj¹ okreœlenie prawid³owoœci wykonywania ¿¹dañ. W powy¿szym przyk³adzie, wartoœci s¹ akceptowalne (œredni czas ¿¹dania to 0.5 sekundy), co najwa¿niejsze nie wystêpuj¹ b³êdy na poziomie serwera WWW i z du¿ym prawdopodobieñstwem równie¿ na poziomie aplikacji. Oczywiœcie zauwa¿alny jest spadek wydajnoœci, w porównaniu z pierwszym testem, co prawda wartoœci œrednie s¹ zbli¿one, jednak widaæ wiêksze rozbie¿noœci miêdzy wartoœciami minimalnymi a maksymalnymi. Najd³u¿sze zapytanie zajê³o ponad 3 sekundy. 

W dokumentacji aplikacji \texttt{ab}, mo¿na znaleŸæ informacjê, ¿e niektóre serwery mog¹ blokowaæ wysy³ane przez niego nag³ówki HTTP. 
W tym celu mo¿na wykorzystaæ prze³¹cznik umo¿liwiaj¹cy podanie siê za inn¹ przegl¹darkê. 
Np. chc¹c zasymulowaæ odwiedziny przy u¿yciu przegl¹darki Chrome nale¿y wykonaæ poni¿sz¹ komendê.
\lstinline{ab -n 100 -c 5 -H "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.2 (KHTML, like Gecko) Chrome/6.0.447.0 Safari/534.2" http://www.example.com}.\\

Pomimo wielu zalet wynikaj¹cych z korzystania z narzêdzia \texttt{ab}, istnieje jedna zasadnicza wada. Aplikacja nie daje mo¿liwoœci przetestowania pewnego scenariusza lub jest to bardzo niewygodne, a przypadku aplikacji z wykorzystaniem technologii \textit{JavaScript} i \textit{AJAX} wrêcz niewykonalne.

Dlatego te¿ na prze³omie lat wyspecjalizowa³y siê bardziej zaawansowane narzêdzia przeznaczone do przeœledzenia logicznej kolejnoœci dzia³añ wykonywanych na stronie (pewnego przypadku u¿ycia) i wykonywanie analiz w³aœnie w ramach logicznego zbioru akcji. W ten sposób mo¿liwe jest przeprowadzenie tzw. \textit{testów funkcjonalnych}, a tak¿e sprawdzenie w jakim stopniu s¹ one wra¿liwe na zwiêkszony ruch sieciowy. 

Jednym z przyk³adów takiego narzêdzia o naprawdê olbrzymich mo¿liwoœciach jest \textit{Apache JMeter}. Z jego pomoc¹ mo¿liwe jest nagranie pewnego ci¹gu akcji wykonanych przy pomocy przegl¹darki, a nastêpnie przeprowadzenie ci¹gu analiz i testów na tak wyodrêbnionym zbiorze. Tabela \ref{table:1_jmeter} pokazuje wynik dzia³ania przyk³adowego scenariusza polegaj¹cego na symulowaniu wejœcia na stronê \texttt{http://www.wp.pl}, a nastêpnie klikniêciu jednego z linków wiadomoœci, po czym klikniêciu na kolejny link z dostêpnych na bie¿¹cej stronie. Ostatnim elementem ³añcucha akcji jest wys³anie komentarza do artyku³u. JMeter podobnie jak \texttt{ab} umo¿liwia wykonywanie równoleg³ych po³¹czeñ u¿ytkowników okreœlanych jako w¹tki (\textit{threads}).\\

W zdefiniowanym przypadku u¿ycia 5 u¿ytkowników wykonuje jednoczeœnie t¹ logikê 500 razy. Na zakoñczenie dane mo¿liwe s¹ do wyeksportowania do formatu \textit{CSV} lub wyœwietlone bezpoœrednio na ekranie. JMeter jest narzêdziem bardzo rozbudowanym, przez co idealnie nadaje siê do testowania zaawansowanych scenariuszy zarówno pod k¹tem poprawnoœci dzia³ania, jak równie¿ ogólnej wydajnoœci.

\begin{table*}\centering
\ra{1.3}
\begin{tabular}{@{}rrrrcrrrcrrr@{}}\toprule
URL & Œrednia & Min & Max & B³¹d (\%) & Req/Min \\
\bottomrule
..14543704,wiadomosc.html & 2299 & 415 & 94329 & 2.2 & 43.7 \\  
...1028235,wiadomosci.html & 2485 & 335 & 94434 & 2.8 & 43.7 \\  
...14545325,wiadomosc.html & 2023 & 394 & 94285 & 1.8 & 43.7 \\  
\bottomrule
£¹cznie & 2269 & 335 & 94434 & 2.27 & 131.1 \\  
\end{tabular}
\caption{Tabela z rezultatem dzia³ania aplikacji JMeter}
\label{table:1_jmeter}
\end{table*}

\section{Analiza wydajnoœci frontendu}

W poprzednim podrozdziale zosta³a omówiona tematyka testowania czasu dzia³ania zasobów serwowanych przez serwer WWW. Wykorzystuj¹c wspomniane wczeœniej narzêdzia mo¿na jednoznacznie ustaliæ czy aplikacja funkcjonuje w sposób prawid³owy, czy nie wystêpuj¹ b³êdy w pracy serwera oraz jak dobrze oprogramowanie radzi sobie ze wzmo¿onym obci¹¿eniem.

Wydawaæ by siê mog³o, ¿e problem testowania wydajnoœci aplikacji zosta³ jednoznacznie omówiony.
Nic bardziej mylnego, jedynie w idealnym œwiecie, strona WWW sk³ada³a by siê wy³¹cznie z tekstu, a u¿ytkownicy do przegl¹dania Internetu, korzystaliby wy³¹cznie z terminali.\\

Obecnie wszyscy u¿ytkownicy korzystaj¹ przynajmniej z jednej przegl¹darki internetowej, dlatego dla wiêkszej precyzji, konieczne jest wyszczególnienie pewnego kluczowego komponentu jakim jest front-end aplikacji. W przypadku aplikacji internetowych, front-end to graficzna nak³adka s³u¿¹ca do komunikacji z u¿ytkownikiem i prezentacji danych opracowanych przez architekturê systemu (back-end) w sposób przystêpny i zrozumia³y dla u¿ytkowników. Odpowiednia optymalizacja frontendu jest o tyle wa¿na, ¿e jest to pierwsza technologia z jak¹ u¿ytkownik ma kontakt w momencie przegl¹dania aplikacji \cite{book:proPHP}.

Frontend jest miejscem analizy i przetwarzania wyniku odpowiedzi serwera. W wiêkszoœci wypadków miejscem osadzenia frontendu jest przegl¹darka WWW, natomiast jêzykiem obowi¹zuj¹cej komunikacji jest jêzyk\linebreak HTML. Od kilku lat w wyniku rozwoju trendu WEB 2.0, istotnym zabiegiem, stron staje siê przeniesienie czêœci logiki aplikacji na stronê przegl¹darki (frontendu). Cienkie do tej pory aplikacje webowe (thin client), zaczynaj¹ dziêki zdobycz¹ technologicznym takim jak AJAX stawaæ siê klientami grubymi. Oznacza to, ¿e przetwarzanie danych mo¿e mieæ miejsce w przegl¹darce internetowej.\\

Dlatego te¿ istotnym elementem analizy wydajnoœciowej jest analiza frontendu. Wœród istniej¹cych na rynku rozwi¹zañ, najpopularniejszymi s¹ te, które s¹ wbudowane bezpoœrednio w interfejs przegl¹darki internetowej. Jednym z pierwszych rozwi¹zañ tego typu by³a wtyczka Firebug napisana dla przegl¹darki Firefox. Jest to obecnie najbardziej zaawansowane narzêdzie tego typu, rywalizuj¹ce jednoczeœnie z natywnymi narzêdziami deweloperskimi dla przegl¹darki Chrome.

Interfejs Firebuga pozwala na szczegó³ow¹ inspekcjê kodu HTML wraz z mo¿liwoœci¹ dynamicznej podmiany jego zawartoœci. Nie mniej wa¿nymi narzêdziami, s¹: mo¿liwoœæ wykonywania i debugowania kodu JavaScript na stronie, inspekcja zwi¹zanego z dokumentem HTML obiektu DOM, edycja i rewizja kodu JavaScript oraz narzêdzie do monitorowania ruchu sieciowego wykonywanego przez aplikacjê.

Ten ostatni modu³ pe³ni podobn¹ rolê do narzêdzia \texttt{ab}, jednak wyœwietla wszystkie zasoby, które maj¹ bezpoœrednie powi¹zanie z bie¿¹cym dokumentem HTML. Omawiane wczeœniej narzêdzia pokazywa³ jedynie czas renderowania dokumentu HTML, jednak nale¿y mieæ na uwadze, ¿e strona internetowa sk³ada siê z wielu ró¿nych zasobów wœród których nie sposób pomin¹æ: grafik, arkuszy CSS, dokumentów JavaScript, apletów Java, dokumentów Flash.

Ka¿da strona mo¿e zawieraæ 0 lub wiêcej takich zasobów, dlatego na ³¹czny czas ³adowania strony sk³ada siê zarówno czas oczekiwania na dokument HTML, jak równie¿ czas konieczny na pobranie ka¿dego z powi¹zanych z nim zasobów. Nawi¹zuj¹c do \cite{book:yahoo} istniej zasada, która mówi, ¿e w wiêkszoœci wypadków tylko 10-20\% czasu odpowiedzi jest spêdzane na oczekiwanie na dokument HTML, natomiast pozosta³e 80-90\% to czas na pobieranie pozosta³ych zasobów.

Rysunek \ref{fig:ruch_sieciowy} jest najlepszym przyk³adem tej zasady. Strona wykonuje 32 zapytania do serwera, z czego tylko jedno to zapytanie o dokument HTML. Pobranie tego dokumentu zajê³o oko³o 400ms, tymczasem ³¹czny czas wczytywania strony wyniós³ 3.21 sekundy. Oznacza to, ¿e generowanie dokumentu zajê³o zaledwie 12\% ³¹cznego czasu oczekiwania. Na podstawie danych z Firebuga ³atwo stwierdziæ pewne nieprawid³owoœci, bowiem w ramach strony wczytywane s¹ 2 stosunkowo du¿e (1,1 MB) dokumenty graficzne, które prawdopodobnie nie zosta³y zeskalowane do odpowiednich rozmiarów. \texttt{Firebug} stanowi, wiêc cenne narzêdzie przy diagnostyce frontendu strony. Staje siê jeszcze przydatniejszy przy pojawianiu siê elementów dynamicznych JavaScript, poniewa¿ pozwala œledziæ zarówno aktualnie wykonywany kod, jak równie¿ nas³uchiwaæ zapytañ asynchronicznych wykonywanych przez AJAX. Narzêdzie to mo¿e byæ równie¿ przydatne podczas œledzenia zmian dokonywanych w dokumencie HTML, za pomoc¹ narzêdzia inspekcji, umo¿liwia zbadanie ka¿dego wêz³a.

\begin{figure}[hbtp]
\includegraphics[scale=0.45]{rys3_firebug.pdf}
\caption{Analiza ruchu sieciowego na stronie http://ftims.p.lodz.pl}
\label{fig:ruch_sieciowy}
\end{figure}

\section{Analiza wydajnoœci bazy danych}

Bardzo czêsto ogólna wydajnoœæ aplikacji uzale¿niona jest od szybkoœci operacji odczytu / zapisu bazy danych. Poci¹ga to za sob¹ równie¿ testy tego wêz³a aplikacji. 