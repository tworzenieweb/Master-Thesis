\chapter{Optymalizacja aplikacji}
\label{cha:optymalizacja_aplikacji}

W ramach poprzednich rozdzia³ów przeœledzono szczegó³owo wszystkie istotne kwestie zwi¹zane z optymalizacj¹ aplikacji webowych. Czas wiêc rozpocz¹æ praktyczn¹ implementacjê oprogramowania.

\section{Framework Django}
\label{section:django}

Framework \textit{Django} powsta³ na bazie jêzyka Python i w nied³ugim czasie zrewolucjonizowa³ proces tworzenia aplikacji internetowych w tym¿e jêzyku. 

\textit{Django} posiada wszystkie cechy, które charakteryzuj¹ narzêdzia do szybkiego tworzenia oprogramowania (\textit{ang. Rapid Application Development}). Podobnie, jak \textit{Ruby on Rails} lub \textit{Symfony}, posiada bibliotekê do mapowania obiektowo - relacyjnego. W ten sposób definiuj¹c obiektowe modele i ich metody, mo¿na bez wiedzy z dziedziny baz danych wykonywaæ na nich operacje. Oczywiœcie w niniejszej pracy, istotna jest kompleksowa znajomoœæ zagadnieñ bazodanowych, dlatego te¿ z jednej strony wykorzystano to narzêdzie w celu przyspieszenia procesu implementacji tworzonej aplikacji, a z drugiej strony trzeba mieæ na uwadze wszystkie omówione w poprzednich rozdzia³ach optymalizacje po stronie silnika bazodanowego \cite{book:django}.\\

Frameworki pokroju \textit{Ruby on Rails} posiadaj¹ atut w postaci \textit{scaffoldingu}, czyli zdolnoœci do generowania podstaw aplikacji przy u¿yciu odpowiednich narzêdzi linii komend. \textit{Django} nie jest pod tym wzglêdem wyj¹tkiem, poniewa¿ umo¿liwia generowanie zarówno bazy aplikacji, jak równie¿ kompletnego panelu administracyjnego, oferuj¹cego zaawansowane funkcje, przydatne na przyk³ad do redagowania strony przez u¿ytkownika koñcowego bez znajomoœci technologii.

W przypadku projektowanej ksiêgarni, za pomoc¹ generatorów \textit{Django} mo¿na w prosty sposób zarz¹dzaæ aplikacj¹ w oparciu o wczeœniej zdefiniowane modele. Oczywiœcie omówione w poprzednim rozdziale rozszerzenie \textit{Django-Norel} umo¿liwi¹ rozszerzenie zakresu dostêpnych baz danych o bazy nierelacyjne. 

\textit{Django-Norel} zapewnia równie¿ narzêdzia, umo¿liwiaj¹ce ³atwe wdro¿enie tworzonego oprogramowania na platformê \textit{Google Application Engine}. Aby jednak mo¿liwe by³o umieszczenie projektu na tej platformie nale¿y zarejestrowaæ darmowe konto. Po zweryfikowaniu jego poprawnoœci mo¿liwe jest utworzenie do \textbf{10} darmowych aplikacji, ka¿dej z w³asn¹ baz¹ \textit{Google Datastore} i zbiorem powi¹zanych us³ug \cite{book:norel}.

\section{Wystawienie us³ug jako webserwisów}

Jednym z powodów wyboru frameworka \textit{Django} jest ³atwa mo¿liwoœæ tworzenia \textit{REST}owych us³ug w oparciu o istniej¹ce modele. Zapewnia to wtyczka \textit{Django-Piston}, która dokonuje \textit{serializacji} do kilku popularnych formatów, w tym do notacji \textit{JSON}. Listing \ref{listing:webservice_handler} przedstawia implementacjê jednej z  us³ug (Komentarzy). Jak widaæ implementacja takiej us³ugi jest dosyæ prosta z wykorzystaniem wspomnianej wczeœniej wtyczki. Wystarczy stworzyæ now¹ klasê, która dziedziczy po bazowej \texttt{BaseHandler}. Nastêpnie okreœlono dozwolone metody HTTP, odpowiedzialne za pobieranie danych, ich tworzenie, aktualizacjê, a koñcz¹c na usuwaniu \cite{book:piston}. 

Piston oferuje mo¿liwoœæ zabezpieczania dostêpu do konkretnych zasobów. W ten sposób tylko osoba znaj¹ca has³o mo¿e dodaæ komentarz lub ocenê. Z drugiej strony mo¿liwe jest stworzenie osobnej wersji us³ugi udostêpniaj¹cej tylko okreœlone operacje. Jak widaæ na listingu \ref{listing:webservice_handler}, odpowiedzialna jest za to klasa \texttt{AnonymousCommentHandler}. Wymieniona us³uga pozwala na dodanie komentarza lub ich podgl¹d. Ostatnia czynnoœæ konieczna do wystawienia us³ugi, to jej zmapowanie na okreœlony adres zasobu. Odpowiedzialny jest za to kod z listingu \ref{listing:webservice_url}. Po wdro¿eniu aplikacji mo¿liwe jest sprawdzenie dzia³ania us³ugi na przyk³ad pod adresem \texttt{http://tworzenieweb.appspot.com\\/api/categories/}. Podany adres zasobu zwraca listê wszystkich kategorii, ³¹cznie z iloœci¹ przypisanych ksi¹¿ek. Listing \ref{listing:webservice_response} przedstawia zwrócony kod w notacji \textit{JSON}.

\begin{lstlisting}[language=python, caption=Implementacja us³ugi odpowiedzialnej za komentarze, label=listing:webservice_handler]
class AnonymousCommentHandler(AnonymousBaseHandler):
    model = Comment
    fields = ('title', 'content', ('user', ('id','first_name', 'last_name', 'username')), 'date', 'grade')

    def read(self, request, book_id):
        return self.model.objects.filter(book = book_id)

class CommentHandler(BaseHandler):
    anonymous = AnonymousCommentHandler
    allowed_methods = ('GET', 'PUT', 'DELETE', 'POST')
    model = Comment
    fields = ('title', 'content', ('user', ('id','first_name', 'last_name', 'username')), 'date', 'grade')   

    def read(self, request, book_id):
        
        self.anonymous.read(request, book_id)
    
    @validate(CommentForm)
    def create(self, request, book_id):
        data = request.data
        
        book = Book.objects.filter(id = book_id).exists()
        
        if not book:
            return rc.NOT_FOUND;
        
        em = self.model(
                        title=data['title'], 
                        content=data['content'], 
                        grade = data['grade'], 
                        book_id = book_id, 
                        user_id = request.user.id
                        )
        em.save()
        
            
        return rc.CREATED


\end{lstlisting}

\begin{lstlisting}[language=python,label=listing:webservice_url, caption=Wystawienie us³ugi komentarzy do publicznego dostêpu]
comment_handler = Resource(CommentHandler, authentication = auth)

urlpatterns = patterns('',
   url(r'^comments/(?P<book_id>\d+)/', comment_handler, { 'emitter_format': 'json' }),
)
\end{lstlisting}

\begin{lstlisting}[language=python,label=listing:webservice_response, caption=Rezultat zwrócony przez us³ugê kategorii]
[
    {
        "count": 0, 
        "id": 3003, 
        "name": "Bazy Danych", 
        "slug": "bazy-danych"
    }, 
    {
        "count": 2, 
        "id": 4005, 
        "name": "Java", 
        "slug": "java"
    }, 
    {
        "count": 1, 
        "id": 13004, 
        "name": "PHP", 
        "slug": "php"
    }
]
\end{lstlisting}

\section{Uruchomienie panelu administracyjnego aplikacji}

Zgodnie z omówionymi w podrozdziale \ref{section:django} mo¿liwoœciami frameworka \textit{Django}, po utworzeniu odpowiednich modeli, mo¿liwe jest dodanie opcji administracyjnych. Rysunek \ref{fig:django_backend} pokazuje wygl¹d zaplecza administracyjnego. Natomiast rysunek \ref{fig:django_backend2} pokazuje przyk³adowy formularz dodawania ksi¹¿ki. Ciekawym udogodnieniem jest wykorzystanie biblioteki \textit{SelectMultiple} napisanej dla frameworka \textit{jQuery}, w celu wygodniejszej pracy z polami list wielokrotnego wyboru. W ten sposób po lewej stronie umieszczone s¹ kategorie, autorzy niewybrani, natomiast po prawej autorzy aktualnie zaznaczeni.

\begin{figure}[htbp]
\caption{Wygl¹d zaplecza administracyjnego stworzonej aplikacji}
\includegraphics[scale=0.6]{django_backend.pdf}
\label{fig:django_backend}
\end{figure}

\begin{figure}[htbp]
\caption{Wygl¹d zaplecza administracyjnego stworzonej ksiêgarni internetowej}
\includegraphics[scale=0.6]{django_backend2.pdf}
\label{fig:django_backend2}
\end{figure}

Jak zosta³o wykazane, framework \textit{Django} w du¿ym stopniu przyspieszy³ proces implementacji docelowej aplikacji na platformie \textit{Google Application Engine}. Jednym z ciekawych udogodnieñ oferowanych przez GAE jest system numeracji wersji. Przyk³adowo dodano do aplikacji now¹ funkcjonalnoœæ, która wymaga testów akceptacyjnych, edytuj¹c specjalny plik \texttt{app.yaml}. Parametr \texttt{version} pozwala na przyk³ad na wdro¿enie aplikacji pod specjaln¹ subdomenê testow¹. Przyk³adowo \texttt{version: staging} spowoduje, ¿e osobna wersja aplikacji dostêpna bêdzie pod adresem \texttt{staging.tworzenieweb.appspot.com}. Dodatkowo, w panelu administracyjnym mo¿liwe jest ustawienie, która z wdro¿onych aplikacji jest aplikacj¹ domyœln¹ (Rys. \ref{fig:gae}). 

\begin{figure}[htbp]
\caption{Zarz¹dzanie wersjami oprogramowania wdro¿onego na platformê \textit{Google Application Engine}}
\includegraphics[scale=0.6]{gae.pdf}
\label{fig:gae}
\end{figure}


\section{Framework Symfony}

Front-end aplikacji zosta³ napisany przy wykorzystaniu frameworka Symfony w wersji 1.4. Powodem wyboru tej technologii jest mo¿liwoœæ szybkiego tworzenia oprogramowania równie¿ z wykorzystaniem generatorów i za³o¿eñ \textit{scaffoldingu}. Obecnie bardzo czêsto daje siê zaobserwowaæ ³¹czenie technologii w sposób podobny do przedstawionego, czyli przyk³adowo zaplecze aplikacji i interfejs bazodanowy tworzony jest w jednej technologii na przyk³ad \textit{Django} albo \textit{Ruby on Rails}, natomiast prezentacja treœci jest wykonana przy u¿yciu jêzyka \textit{PHP}. Dzieje siê tak, poniewa¿ PHP jest doskonale dostosowane do tworzenia dokumentów koñcowych w jêzyku HTML.

Dla przyspieszenia tworzenia czêœci przegl¹dowej aplikacji, utworzono wykorzystuj¹c \textit{Doctrine ORM} \cite{book:doctrine}, schemat bazy danych to¿samy z tym który znajduje siê w \textit{back-endzie}. Tak naprawdê jest on potrzebny wy³¹cznie do wygenerowania formularzy danych, poniewa¿ jak zosta³o wspomniane, operacje bazodanowe s¹ wykonywane wykorzystuj¹c webserwisy.

Istotnym udogodnieniem w interfejsie u¿ytkownika jest wykorzystanie wtyczki \textit{jQuery Validation}. Wykorzystuj¹c t¹ bibliotekê, mo¿liwe jest wykonanie sprawdzania poprawnoœci danych, wprowadzonych do poszczególnych pól.  Ca³oœæ jest zintegrowana z klasami formularzy \textit{Symfony} \cite{book:symfony}, wiêc w momencie ustalenia przez aplikacjê rodzaju formularza, tworzony jest automatyczny plik regu³ walidacji (Listing \ref{listing:reguly}), który jest nastêpnie do³¹czany do Ÿród³a strony. Jeœli kod \textit{JavaScript} jest w³¹czony w przegl¹darce, to skrypt nie pozwoli na wys³anie formularza i bêdzie pokazywa³ odpowiednie b³êdy na stronie.

\begin{lstlisting}[language=java, caption=Przyk³adowy zbiór regu³ sprawdzania danych formularzy po stronie klienta, label=listing:reguly]
processForm = function(form) {
    form.submit();
}

jQuery(function($){
  
  $('#id').parents('form').validate({
    rules: {"first_name":{"maxlength":255},"last_name":{"maxlength":255},"email_address":{"required":true,"email":true},"username":{"required":true,"maxlength":128},"password":{"required":true,"maxlength":128},"password_again":{"maxlength":128}},
    messages: {"first_name":{"maxlength":function(a, elem){ return '\\\"' + $(elem).val() + '\\\" is too long (255 characters max).';}},"last_name":{"maxlength":function(a, elem){ return '\\\"' + $(elem).val() + '\\\" is too long (255 characters max).';}},"email_address":{"required":"Required.","email":"You should provide valid email address"},"username":{"required":"Required.","maxlength":function(a, elem){ return '\\\"' + $(elem).val() + '\\\" is too long (128 characters max).';}},"password":{"required":"Required.","maxlength":function(a, elem){ return '\\\"' + $(elem).val() + '\\\" is too long (128 characters max).';}},"password_again":{"maxlength":function(a, elem){ return '\\\"' + $(elem).val() + '\\\" is too long (128 characters max).';}}},
    onkeyup: false,
    wrapper: 'span class="help-inline"',
    errorElement: 'span',
    errorPlacement: function(error, element) 
    {
    
     element.parent().parent().addClass('error');
    
     if(element.parents('.radio_list').is('*') || element.parents('.checkbox_list').is('*'))
     {
       error.appendTo( element.parent().parent().parent() );
     }
     else
     {
       error.appendTo( element.parent() );
     }

   },
   submitHandler: function(form) {
     
    processForm(form);
     
   }
  
  });
  
  $('#password_again').rules('add', {"equalTo":"#password","messages":{"equalTo":"The two passwords must be the same."}});
      
});

/* for some reason the jQuery Validate plugin does not incluce a generic regex method */
jQuery.validator.addMethod(
  "regex",
  function(value, element, regexp) {
      if (regexp.constructor != RegExp)
          regexp = new RegExp(regexp);
      else if (regexp.global)
          regexp.lastIndex = 0;
      return this.optional(element) || regexp.test(value);
  },
  "Invalid."
);
\end{lstlisting}

Rysunek \ref{fig:register_validation} pokazuje rezultat dzia³ania walidacji formularza Dopiero kiedy wszystkie b³êdy zostan¹ poprawione, skrypt pozwoli na wys³anie ¿¹dania typu POST do docelowej us³ugi. Takie podejœcie w du¿ym stopniu ogranicza ruch sieciowy w aplikacji. Oczywiœcie oprócz walidacji danych po stronie klienta, nale¿y równie¿ bezwzglêdnie sprawdzaæ dane po stronie serwera, poniewa¿ mo¿e to prowadziæ do znacznych uchybieñ w bezpieczeñstwie aplikacji.\\

Innym wa¿nym udogodnieniem jest modyfikacja istniej¹cej wtyczki, odpowiedzialnej za ochronê dostêpu do aplikacji. Wtyczka \textit{sfDoctrineGuardPlugin} z za³o¿enia dzia³a³a z baz¹ danych, wiêc w punktach odpowiedzialnych za logowanie do aplikacji, pobieranie obiektu u¿ytkownika lub tworzenie nowego profilu, nale¿a³o zmodyfikowaæ kod. W ten sposób zamiast wykonywaæ zapytania do bazy, serwer lub obiekt \textit{XMLHttpRequest} wysy³a ¿¹danie do aplikacji na platformie GAE i przetwarza zwrócony rezultat. W wypadku uwierzytelnienia konieczne jest zapisanie danych u¿ytkownika do sesji, wiêc od tej pory aplikacja zapamiêta skojarzony obiekt u¿ytkownika.

\begin{figure}[H]
\caption{Wynik dzia³ania wtyczki \textit{jQuery validation}}
\includegraphics[scale=0.7]{register_validation.pdf}
\label{fig:register_validation}
\end{figure}


\section{Test wydajnoœci \textit{webserwisów}}

W celu sprawdzenia faktycznej wydajnoœci us³ug, wykonano kilka testów sprawdzaj¹cych zarówno dzia³anie operacji odczytu, jak równie¿ zapisu.
Jak widaæ na listingu \ref{listing:testgae}, test przeszed³ bardzo sprawnie, osi¹gaj¹c liczbê prawie 60 ¿¹dañ na sekundê. Test by³ przeprowadzany dla \textbf{100} u¿ytkowników jednoczeœnie. Nastêpnie zosta³a sprawdzona us³uga komentarzy (Listing \ref{listing:testkoment}). W wypadku komentarzy test wypad³ trochê gorzej, ale zwi¹zane jest to z wiêkszym skomplikowaniem tej us³ugi i wiêksz¹ iloœci¹ danych do pobrania. Wynik \textbf{37.6} ¿¹dania na sekundê jest bardzo wysok¹ wartoœci¹ i z pewnoœci¹ gwarantuje szybkie dzia³anie aplikacji.\\

Dodatkowo, w celu przyspieszenia operacji odczytu w encjach \textit{kategorii} oraz \textit{ksi¹¿ek} przechowywane s¹ informacje o œredniej ocen pochodz¹ce z komentarzy, jak równie¿ iloœæ ksi¹¿ek przechowywana w danej kategorii. Oznacza to pewn¹ nadmiarowoœæ, ale jest ona konieczna w tego typu rozwi¹zaniach i powszechnie stosowana.\\

Jak widaæ na listingu \ref{listing:testfrontend}, odci¹¿enie \textit{front-endu} testowane na lokalnym komputerze równie skutecznie radzi sobie z obs³u¿eniem skokowym 100 u¿ytkowników. W przysz³oœci mo¿na przenieœæ kod \textit{front-endu} równie¿ na jedno z rozwi¹zañ opartych na chmurze dla jêzyka \textit{PHP}. Oferuje to na przyk³ad hosting \textit{pagoda box} (\texttt{https://pagodabox.com/}). Na lokalnym œrodowisku testowym wykorzystano serwer \textit{Ngnix}, który cechuje siê du¿o mniejszym narzutem pamiêci ni¿ na przyk³ad serwer \textit{Http Apache}.

\begin{lstlisting}[label=listing:testgae, caption=Test wydajnoœci us³ugi pobierania kategorii w ramach stworzonej aplikacji]
Server Software:        Google
Server Hostname:        tworzenieweb2.appspot.com

Document Path:          /api/categories
Document Length:        0 bytes

Concurrency Level:      100
Time taken for tests:   1.721 seconds
Complete requests:      100
Failed requests:        0
Write errors:           0
Requests per second:    58.11 [#/sec] (mean)
Time per request:       1720.744 [ms] (mean)
Time per request:       17.207 [ms] (mean, across all concurrent requests)
Transfer rate:          12.20 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       86  174  48.5    175     256
Processing:   294  765 297.3    796    1466
Waiting:      293  764 297.2    794    1465
Total:        379  939 328.0    931    1718

\end{lstlisting}


\begin{lstlisting}[label=listing:testkoment, caption=Test wydajnoœci us³ugi komentarzy]
Server Software:        Google
Server Hostname:        tworzenieweb2.appspot.com

Document Path:          /api/comments/6/


Concurrency Level:      100
Time taken for tests:   7.879 seconds
Complete requests:      100
Failed requests:        0
Write errors:           0
Total transferred:      243500 bytes
HTML transferred:       210200 bytes
Requests per second:    37.59 [#/sec] (mean)
Time per request:       27879.412 [ms] (mean)
Time per request:       278.794 [ms] (mean, across all concurrent requests)
Transfer rate:          8.53 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       64 121 60     68   270
Processing:   270  761 332.0    723    1647
Waiting:      268  760 332.0    722    1646
Total:        339 1014 3563.3    847   16173


\end{lstlisting}

\begin{lstlisting}[caption=Test \textit{front-endu} aplikacji na lokalnym komputerze, label=listing:testfrontend]
Server Software:        nginx/1.1.19
Server Hostname:        thesis.web.dev
Server Port:            80

Document Path:          /
Document Length:        6621 bytes

Concurrency Level:      100
Time taken for tests:   2.747 seconds
Complete requests:      100
Failed requests:        0
Write errors:           0
Total transferred:      694500 bytes
HTML transferred:       662100 bytes
Requests per second:    36.40 [#/sec] (mean)
Time per request:       2747.185 [ms] (mean)
Time per request:       27.472 [ms] (mean, across all concurrent requests)
Transfer rate:          246.88 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        2    3   0.8      3       5
Processing:    77 1496 801.5   1509    2742
Waiting:       77 1496 801.5   1509    2742
Total:         82 1499 801.7   1512    2746


\end{lstlisting}

Potencja³ aplikacji wynikaj¹cy z uzyskanych wyników, pokazuje, ¿e rozproszenie us³ug ma g³êboki sens i przynosi wymierne rezultaty. Celem pracy nie by³o pokazanie wy³¹cznie korzyœci zwi¹zanych z wydajnoœci¹ aplikacji. Dziêki dekompozycji aplikacji na warstwê us³ugow¹ (webserwisy) i warstwê prezentacyjn¹ zyskujemy du¿¹ elastycznoœæ. W ka¿dej chwili mo¿na podmieniæ platformê \textit{GAE} na zupe³nie inne rozwi¹zanie, maj¹c na uwadze zachowanie struktury obiektów zwracanych przez webserwisy. Nie wp³ynie to w ¿adnym stopniu na dzia³anie czêœci prezentacyjnej. Wa¿ne jest jednak by obiekty \textit{JSON} pasowa³y do wczeœniej ustalonej struktury.

Oprócz optymalizacji \textit{back-endu} aplikacji, nie bez znaczenia jest równie¿ praca wykonana po stronie \textit{front-endu}. Implementacja pocz¹tkowej walidacji danych z wykorzystaniem \textit{JavaScriptu}, pozwoli na szybsz¹ detekcje b³êdów w formularzach, co z pewnoœci¹ doceni¹ u¿ytkownicy. Z drugiej strony moment wys³ania ¿¹dania do serwera zostaje opóŸniony do momentu kiedy jest ju¿ du¿a pewnoœæ prawid³owoœci danych.

Asynchroniczne pobieranie komentarzy to kolejny krok poprawiaj¹cy jakoœæ stworzonej aplikacji. W podejœciu synchronicznym, na pocz¹tku pobrano by z bazy dane o ksi¹¿ce, nastêpnie dane o komentarzach powi¹zanych ze stron¹. Dziêki technologii \textit{AJAX}, te dwa zadania mog¹ byæ wykonywane jednoczeœnie. Serwer WWW generuje tylko absolutn¹ podstawê strony, pozosta³e komponenty s¹ do³¹czane w miêdzyczasie. Przek³adaj¹c omówione zagadnienie na bardziej ¿yciowe porównanie - o ile szybciej mo¿liwe jest wybudowanie domu, jeœli jednoczeœnie kopane s¹ fundamenty, stawiane mury domu i k³adziony dach.